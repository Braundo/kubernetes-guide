{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":"<p>Welcome to the Kubernetes Guide, a quick and easy-to-digest summary of core Kubernetes concepts intended to help get you from zero to proficient!</p> <p>One thing to note about text formatting in this guide: you'll notice some terms start with a capital letter (i.e. Service, Pod, etc.). This is intentional and an attempt to adhere to standard formatting as laid out in the official Kubernetes documentation. Kubernetes API objects (like the ones just mentioned) should start with a capital letter.</p> <p>Legal disclaimer:  \"Kubernetes\", \"K8s\", and the Kubernetes logo are trademarks or registered trademarks of the Linux Foundation.  Neither myself nor this site are officially associated with the Linux Foundation.</p> <p> Connect with me  Suggest changes</p>"},{"location":"about/","title":"About","text":"<p>My name is Aaron Braundmeier and I've been working in the tech industry for over a decade at companies such as Mastercard, VMware, Broadcom and CVS. I've long been a Kubernetes fan and had the privilege of working hands-on in that space during my time within the Tanzu business unit at VMware. Please note that all opinions and content on this site belong to me and do not reflect the opinions, plans, or designs of any of my current or former employers.</p> <p></p> <p>I'm currently working on attaining Kubestronaut status:</p> <ul> <li> Certified Kubernetes Administrator (CKA)</li> <li> Kubernetes Certified Security Associate (KCSA)</li> <li> Kubernetes and Cloud Native Associate (KCNA)</li> <li> Certified Kubernetes Security Specialist (CKS)</li> <li> Certified Kubernetes Application Developer (CKAD)</li> </ul> <p> If you're interested in connecting, I can be reached in the following ways:</p> <p> aaron@braundmeier.com</p> <p> LinkedIn</p> <p> Signal</p> <p></p> Certified Kubernetes Administrator Issuer: The Linux Foundation Kubernetes and Cloud Security Associate Issuer: The Linux Foundation Kubernetes and Cloud Native Associate Issuer: The Linux Foundation AWS Certified Cloud Practitioner Issuer: The Linux Foundation Certified Argo Project Associate Issuer: The Linux Foundation"},{"location":"audit-logging/","title":"Audit & Logging","text":"<p>In Kubernetes, audit logging and centralized log collection are critical components of a secure and observable platform. Audit logs help detect policy violations or suspicious behavior, while application and cluster logs help with troubleshooting, monitoring, and forensics.</p> Audit Logs in Kubernetes <p>Kubernetes audit logs record the who, what, when, and where of every request made to the Kubernetes API server. These logs are essential for security analysis, compliance, and intrusion detection.  Audit logging must be configured explicitly and is typically enabled on the control plane node(s).</p>"},{"location":"audit-logging/#key-fields-in-audit-events","title":"Key Fields in Audit Events","text":"<p>Each audit log entry includes:</p> <ul> <li><code>user.username</code>: Who initiated the request</li> <li><code>verb</code>: What operation was attempted (e.g. <code>create</code>, <code>get</code>, <code>patch</code>)</li> <li><code>objectRef</code>: Which resource was affected</li> <li><code>responseStatus</code>: Whether it succeeded or failed</li> <li><code>stage</code>: The phase of request processing (e.g. <code>RequestReceived</code>, <code>ResponseComplete</code>)</li> </ul>"},{"location":"audit-logging/#example-json-entry-simplified","title":"Example JSON Entry (Simplified)","text":"<pre><code>{\n  \"kind\": \"Event\",\n  \"apiVersion\": \"audit.k8s.io/v1\",\n  \"user\": {\n    \"username\": \"admin\"\n  },\n  \"verb\": \"create\",\n  \"objectRef\": {\n    \"resource\": \"pods\",\n    \"namespace\": \"default\",\n    \"name\": \"nginx\"\n  },\n  \"responseStatus\": {\n    \"code\": 201\n  },\n  \"stage\": \"ResponseComplete\"\n}\n</code></pre>"},{"location":"audit-logging/#enabling-audit-logging","title":"Enabling Audit Logging","text":"<p>Audit logging is configured via the <code>--audit-policy-file</code> and <code>--audit-log-path</code> flags on the API server.</p>"},{"location":"audit-logging/#example-startup-flags","title":"Example startup flags:","text":"<pre><code>--audit-policy-file=/etc/kubernetes/audit-policy.yaml\n--audit-log-path=/var/log/kubernetes/audit.log\n</code></pre> <p>You also define a policy file to control which events get logged:</p> <pre><code>apiVersion: audit.k8s.io/v1\nkind: Policy\nrules:\n  - level: Metadata\n    verbs: [\"create\", \"delete\"]\n    resources:\n      - group: \"\"\n        resources: [\"pods\"]\n</code></pre>"},{"location":"audit-logging/#centralized-logging-stack","title":"Centralized Logging Stack","text":"<p>To collect and analyze logs from applications, control plane components, and nodes, you\u2019ll typically deploy a logging stack.</p>"},{"location":"audit-logging/#common-choices","title":"Common Choices:","text":"Tool Purpose Fluent Bit Lightweight log forwarder (agent) Fluentd Full-featured log collector/transformer Loki Scalable log store optimized for Kubernetes Elasticsearch Popular full-text search engine Kibana / Grafana Visualization dashboards <p>These tools collect logs from container stdout/stderr or files (e.g., <code>/var/log/containers/</code>) and ship them to a centralized location.</p>"},{"location":"audit-logging/#recommended-architecture","title":"Recommended Architecture","text":"<p>A typical Kubernetes logging pipeline:</p> <pre><code>Pods/Containers\n     \u2193\nFluent Bit / Fluentd (DaemonSet)\n     \u2193\nLoki / Elasticsearch / Custom Sink\n     \u2193\nGrafana / Kibana / Alerting Tools\n</code></pre> <p>This allows:</p> <ul> <li>Full-text search over logs</li> <li>Filtering by label, container, namespace, or timestamp</li> <li>Long-term storage for audit/compliance</li> <li>Alerts on suspicious activity</li> </ul>"},{"location":"audit-logging/#best-practices","title":"Best Practices","text":"<ul> <li>Rotate and retain audit logs securely (e.g., via logrotate or cloud log sinks)</li> <li>Don\u2019t log full request/response bodies unless necessary</li> <li>Separate audit logs from normal logs in storage and access control</li> <li>Use RBAC to restrict access to sensitive audit and control plane logs</li> <li>Encrypt logs in transit and at rest if stored outside the cluster</li> </ul>"},{"location":"audit-logging/#summary","title":"Summary","text":"<p>Audit logging and centralized logging are essential for both security and observability in Kubernetes. Audit logs capture cluster-level events for compliance and threat detection, while the logging stack enables real-time visibility and operational insights. Both should be included in any production-grade Kubernetes deployment.</p>"},{"location":"certification-preparation/","title":"Kubernetes Certification Preparation","text":"<p>The CNCF offers several certifications to validate your Kubernetes knowledge. This section helps you prepare for the three core exams:</p> <ul> <li>Certified Kubernetes Administrator (CKA)</li> <li>Certified Kubernetes Application Developer (CKAD)</li> <li>Certified Kubernetes Security Specialist (CKS)</li> </ul> <p>Each guide includes:</p> <ul> <li>Core topics you need to master</li> <li>Trusted resources and courses</li> <li>Practical exam tips and environment setup</li> </ul>"},{"location":"certification-preparation/#exam-overview","title":"Exam Overview","text":"Cert Duration Format Focus Area CKA 2 hours Hands-on lab Cluster operations, admin CKAD 2 hours Hands-on lab App design, deployment CKS 2 hours Hands-on lab Security and hardening"},{"location":"certification-preparation/#general-advice","title":"General Advice","text":"<ul> <li>Practice in a real cluster  -  don\u2019t rely only on theory</li> <li>Learn to navigate <code>kubectl</code> quickly  -  alias everything</li> <li>Master <code>vim</code>, <code>tmux</code>, and <code>kubectl explain</code></li> <li>Use tab-complete and <code>kubectl -h</code> constantly</li> <li>Use <code>--dry-run=client -o yaml</code> for rapid manifest generation</li> </ul>"},{"location":"certification-preparation/#resources","title":"Resources","text":""},{"location":"certification-preparation/#books","title":"Books","text":"Book Title Link Kubernetes Up &amp; Running Kubernetes Up &amp; Running The Kubernetes Book The Kubernetes Book Certified Kubernetes Administrator Study Guide Certified Kubernetes Administrator Study Guide Quick Start Kubernetes Quick Start Kubernetes Networking &amp; Kubernetes Networking &amp; Kubernetes Kubernetes Best Practices Kubernetes Best Practices The Book of Kubernetes The Book of Kubernetes"},{"location":"certification-preparation/#documentation","title":"Documentation","text":"Description Link Official Kubernetes documentation Kubernetes Documentation"},{"location":"certification-preparation/#online-courses","title":"Online Courses","text":"Course Link CKA Course on Udemy CKA Course on Udemy CKAD Design &amp; Build on Pluralsight CKAD Design &amp; Build on Pluralsight"},{"location":"certification-preparation/#practice-labs","title":"Practice Labs","text":"Description Link Katacoda Katacoda Play with Kubernetes Play with Kubernetes Killer Shell killer.sh <p>Note: You\u2019ll have access to kubernetes.io/docs and github.com/kubernetes during the exam.</p>"},{"location":"certification-preparation/#ready-to-dive-in","title":"Ready to Dive In?","text":"<p>Choose your path:</p> <ul> <li>\ud83d\udc49 CKA \u2013 Admin-focused</li> <li>\ud83d\udc49 CKAD \u2013 Developer-focused</li> <li>\ud83d\udc49 CKS \u2013 Security-focused</li> </ul>"},{"location":"cka/","title":"Certified Kubernetes Administrator (CKA)","text":"<p>The Certified Kubernetes Administrator (CKA) exam tests your ability to install, configure, and manage Kubernetes clusters in real-world scenarios. It focuses heavily on system-level operations, cluster components, and day-to-day administrator tasks.</p>"},{"location":"cka/#exam-overview","title":"\ud83e\udde0 Exam Overview","text":"<ul> <li>Format: Hands-on, performance-based lab</li> <li>Duration: 2 hours</li> <li>Passing score: 66%</li> <li>Price: $395 USD (includes one retake)</li> <li>Open book: Access to kubernetes.io/docs and GitHub</li> </ul>"},{"location":"cka/#domains-weights","title":"\ud83d\udccb Domains &amp; Weights","text":"Domain Weight Cluster Architecture, Installation &amp; Configuration 25% Workloads &amp; Scheduling 15% Services &amp; Networking 20% Storage 10% Troubleshooting 30%"},{"location":"cka/#what-you-should-master","title":"\u2705 What You Should Master","text":""},{"location":"cka/#1-cluster-architecture-setup-25","title":"1. Cluster Architecture &amp; Setup (25%)","text":"<ul> <li><code>kubeadm init</code>, <code>join</code>, <code>reset</code></li> <li>Control plane components: API server, scheduler, controller manager</li> <li>Node components: kubelet, kube-proxy, container runtime</li> <li><code>kubectl config</code> + kubeconfig structure</li> <li>Certificate management (CA, client certs)</li> <li><code>etcdctl</code> backup and restore</li> <li>Static Pods and manifests in <code>/etc/kubernetes/manifests</code></li> <li>Taints and tolerations</li> </ul>"},{"location":"cka/#2-workloads-scheduling-15","title":"2. Workloads &amp; Scheduling (15%)","text":"<ul> <li>Deployments, ReplicaSets, Jobs, CronJobs</li> <li>Labels, selectors, and affinity/anti-affinity rules</li> <li>Taints, tolerations, and node selectors</li> <li>DaemonSets</li> </ul>"},{"location":"cka/#3-services-networking-20","title":"3. Services &amp; Networking (20%)","text":"<ul> <li>ClusterIP, NodePort, LoadBalancer</li> <li>CoreDNS troubleshooting</li> <li>NetworkPolicies (basic understanding)</li> <li>Ingress (YAML-level familiarity)</li> <li>Pod-to-Pod communication</li> </ul>"},{"location":"cka/#4-storage-10","title":"4. Storage (10%)","text":"<ul> <li>Volumes and volumeMounts</li> <li>PersistentVolumes (PV) and PersistentVolumeClaims (PVC)</li> <li>StorageClasses</li> <li>AccessModes and reclaim policies</li> </ul>"},{"location":"cka/#5-troubleshooting-30","title":"5. Troubleshooting (30%)","text":"<ul> <li>Pod/container status (<code>kubectl describe</code>, logs, events)</li> <li><code>kubectl exec</code>, <code>port-forward</code></li> <li>CrashLoopBackOff, ImagePullBackOff</li> <li>Control plane failure detection (kubelet, etcd, API server)</li> <li>Networking and DNS issues</li> <li>Resource scheduling issues (taints, affinity, nodeSelector)</li> <li>CNI problems</li> </ul>"},{"location":"cka/#practice-tips","title":"\u2699\ufe0f Practice Tips","text":"<ul> <li>Set up a local cluster using <code>kubeadm</code> (or use labs like Killer.sh)</li> <li>Use <code>kubectl explain</code> often to understand object structure</li> <li>Use <code>kubectl -n kube-system get pods</code> to monitor system health</li> <li>Alias these commands:</li> </ul> <pre><code>alias k=kubectl\nalias kgp='kubectl get pods'\nalias kaf='kubectl apply -f'\n</code></pre> <ul> <li>Practice writing manifests quickly with:</li> </ul> <pre><code>kubectl run nginx --image=nginx --dry-run=client -o yaml\n</code></pre> <ul> <li>Use <code>kubectl edit</code> and <code>kubectl patch</code> to modify resources live</li> </ul>"},{"location":"cka/#test-environment-tips","title":"\ud83e\uddea Test Environment Tips","text":"<ul> <li>Open multiple terminal tabs (one for docs, one for kubectl)</li> <li> <p>Bookmark key doc pages:</p> <ul> <li>Install tools</li> <li>Tasks \u2192 Configure Pods</li> <li>Reference</li> </ul> </li> <li> <p>Use <code>/etc/kubernetes/manifests/</code> for static Pod edits</p> </li> <li>Save <code>etcd</code> backup and restore syntax</li> </ul>"},{"location":"cka/#recommended-resources","title":"\ud83d\udcda Recommended Resources","text":"<ul> <li>Kubernetes Official Docs</li> <li>Killer.sh Simulator (free with CKA)</li> <li>KodeKloud CKA Course</li> <li>Linux Foundation CKA Training</li> <li>YouTube: TechWorld with Nana \u2013 CKA Series</li> </ul>"},{"location":"cka/#summary","title":"Summary","text":"<p>The CKA exam simulates real-world cluster admin tasks. You\u2019ll be troubleshooting, configuring, deploying, and debugging in a live cluster. With good YAML speed and familiarity with <code>kubectl</code>, you\u2019ll be ready to pass with confidence.</p> <p>Start with the fundamentals. Practice under time pressure. Know where to look in the docs.</p>"},{"location":"ckad/","title":"Certified Kubernetes Application Developer (CKAD)","text":"<p>The CKAD certification tests your ability to design, build, and run applications in Kubernetes. It's focused on real-world usage of Kubernetes primitives - deployments, configs, probes, volumes, and services - from a developer's perspective.</p>"},{"location":"ckad/#exam-overview","title":"\ud83e\udde0 Exam Overview","text":"<ul> <li>Format: Hands-on, browser-based lab</li> <li>Duration: 2 hours</li> <li>Passing score: 66%</li> <li>Price: $395 USD (includes one retake)</li> <li>Open book: Access to kubernetes.io/docs</li> </ul>"},{"location":"ckad/#domains-weights","title":"\ud83d\udccb Domains &amp; Weights","text":"Domain Weight Core Concepts 13% Configuration 18% Multi-Container Pods 10% Observability 18% Pod Design 20% Services &amp; Networking 13% State Persistence 8%"},{"location":"ckad/#what-you-should-master","title":"\u2705 What You Should Master","text":""},{"location":"ckad/#1-core-concepts-13","title":"1. Core Concepts (13%)","text":"<ul> <li>Pod lifecycle and restart policies</li> <li>YAML basics: <code>kind</code>, <code>metadata</code>, <code>spec</code></li> <li><code>kubectl explain</code>, <code>run</code>, <code>logs</code>, <code>exec</code></li> </ul>"},{"location":"ckad/#2-configuration-18","title":"2. Configuration (18%)","text":"<ul> <li>ConfigMaps &amp; Secrets (env and volumes)</li> <li><code>env</code>, <code>envFrom</code>, <code>valueFrom</code></li> <li>Probes: liveness, readiness, startup</li> <li>Resource <code>requests</code> and <code>limits</code></li> <li><code>initContainers</code></li> </ul>"},{"location":"ckad/#3-pod-design-20","title":"3. Pod Design (20%)","text":"<ul> <li>Deployments, ReplicaSets, Jobs, CronJobs</li> <li>Multi-container Pods (sidecar pattern)</li> <li>Labels &amp; selectors</li> <li>Rolling updates &amp; rollbacks</li> </ul>"},{"location":"ckad/#4-multi-container-pods-10","title":"4. Multi-Container Pods (10%)","text":"<ul> <li>Sharing volumes, network namespace</li> <li>Common patterns:</li> <li>Sidecar (logging, proxy)</li> <li>Adapter (log converter, translator)</li> <li>Ambassador (external traffic entrypoint)</li> </ul>"},{"location":"ckad/#5-observability-18","title":"5. Observability (18%)","text":"<ul> <li><code>kubectl logs</code>, <code>describe</code>, <code>top</code></li> <li>Events and debugging Pods</li> <li>Container exit codes and status</li> <li>Custom probes for health checks</li> <li>Monitoring concepts (but not setup)</li> </ul>"},{"location":"ckad/#6-services-networking-13","title":"6. Services &amp; Networking (13%)","text":"<ul> <li>ClusterIP, NodePort (no LoadBalancer config needed)</li> <li>Headless Services</li> <li>DNS-based Pod discovery</li> <li>Understanding service selectors</li> </ul>"},{"location":"ckad/#7-state-persistence-8","title":"7. State Persistence (8%)","text":"<ul> <li>Volumes and volumeMounts</li> <li>PersistentVolumeClaims (PVCs)</li> <li>AccessModes: <code>ReadWriteOnce</code>, <code>ReadOnlyMany</code></li> <li>EmptyDir (for temporary scratch space)</li> </ul>"},{"location":"ckad/#practice-tips","title":"\u2699\ufe0f Practice Tips","text":"<ul> <li>Alias often-used commands:</li> </ul> <pre><code>alias k=kubectl\nalias kgp='kubectl get pods'\nalias kaf='kubectl apply -f'\n</code></pre> <ul> <li>Use dry-run + output:</li> </ul> <pre><code>kubectl run nginx --image=nginx --dry-run=client -o yaml\n</code></pre> <p>Practice common configs: - YAML for Pods with ConfigMap/Secret env vars - Liveness and readiness probes - Multi-container Pod with shared volume</p>"},{"location":"ckad/#test-environment-tips","title":"\ud83e\uddea Test Environment Tips","text":"<ul> <li>Open docs in one tab, terminal in another</li> <li> <p>Bookmark these:</p> <ul> <li>Tasks</li> <li>kubectl Cheat Sheet</li> <li>Workloads Overview</li> </ul> </li> <li> <p>Use <code>kubectl explain</code> to recall spec fields quickly</p> </li> <li>Copy/paste manifest scaffolds from the docs to save time</li> </ul>"},{"location":"ckad/#recommended-resources","title":"\ud83d\udcda Recommended Resources","text":"<ul> <li>Kubernetes Official Docs</li> <li>Killer.sh Simulator</li> <li>KodeKloud CKAD Course</li> <li>Linux Foundation CKAD Training</li> <li>YouTube: TechWorld with Nana \u2013 CKAD Series</li> </ul>"},{"location":"ckad/#summary","title":"Summary","text":"<p>The CKAD exam tests your Kubernetes fluency as a developer. You\u2019ll create and configure Pods, manage configs and secrets, debug issues, and expose applications.</p> <p>If you\u2019re confident writing manifests and using <code>kubectl</code> with speed, you\u2019re ready to pass.</p>"},{"location":"cks/","title":"Certified Kubernetes Security Specialist (CKS)","text":"<p>The CKS certification tests your ability to secure Kubernetes clusters and workloads. It\u2019s hands-on, intense, and assumes you already understand Kubernetes deeply (CKA is a prerequisite).</p>"},{"location":"cks/#exam-overview","title":"\ud83e\udde0 Exam Overview","text":"<ul> <li>Format: Hands-on lab with scenarios</li> <li>Duration: 2 hours</li> <li>Passing score: 67%</li> <li>Prerequisite: Active CKA certification</li> <li>Open book: Access to kubernetes.io + GitHub repos</li> </ul>"},{"location":"cks/#domains-weights","title":"\ud83d\udccb Domains &amp; Weights","text":"Domain Weight Cluster Setup 10% System Hardening 15% Minimize Microservice Vulnerabilities 20% Supply Chain Security 20% Monitoring, Logging &amp; Runtime Security 25% RBAC &amp; Network Policies 10%"},{"location":"cks/#what-you-should-master","title":"\u2705 What You Should Master","text":""},{"location":"cks/#1-cluster-setup-10","title":"1. Cluster Setup (10%)","text":"<ul> <li>TLS certificates &amp; CA bundles</li> <li>Encrypt secrets at rest (KMS + <code>EncryptionConfiguration</code>)</li> <li>Audit policy config and log location</li> <li>API server flags: <code>--audit-log-path</code>, <code>--enable-admission-plugins</code></li> </ul>"},{"location":"cks/#2-system-hardening-15","title":"2. System Hardening (15%)","text":"<ul> <li>Restrict host access: block <code>hostPath</code>, <code>hostNetwork</code>, <code>privileged</code></li> <li> <p>Use <code>securityContext</code>:</p> <ul> <li><code>runAsNonRoot</code>, <code>readOnlyRootFilesystem</code>, <code>allowPrivilegeEscalation: false</code></li> </ul> </li> <li> <p>Restrict capabilities (<code>capabilities.drop: [\"ALL\"]</code>)</p> </li> <li>Pod Security Admission (PSA) with restricted profile</li> <li>Runtime namespace protections (AppArmor / seccomp)</li> </ul>"},{"location":"cks/#3-minimize-microservice-vulnerabilities-20","title":"3. Minimize Microservice Vulnerabilities (20%)","text":"<ul> <li>Scan images with Trivy, Grype, or Dockle</li> <li>Sign images with cosign and verify before deployment</li> <li>Use scratch/minimal base images</li> <li>Avoid running as root in Dockerfiles</li> <li>Validate liveness/readiness probe security</li> </ul>"},{"location":"cks/#4-supply-chain-security-20","title":"4. Supply Chain Security (20%)","text":"<ul> <li>Use trusted registries and signed images</li> <li>Scan YAML manifests for insecure configurations (e.g., <code>kubesec</code>, <code>kube-score</code>)</li> <li> <p>Admission control:</p> <ul> <li>Validating/mutating webhooks</li> <li>Gatekeeper/OPA policies</li> </ul> </li> <li> <p>ImagePullPolicy: <code>Always</code></p> </li> </ul>"},{"location":"cks/#5-monitoring-logging-runtime-security-25","title":"5. Monitoring, Logging &amp; Runtime Security (25%)","text":"<ul> <li>Audit policy and log filtering</li> <li> <p>Tools:</p> <ul> <li>Falco (real-time threat detection)</li> <li>Sysdig, AuditD, or <code>ausearch</code></li> </ul> </li> <li> <p>Monitor execs, privilege escalation, network anomalies</p> </li> <li>Understand and tune Falco rules</li> </ul>"},{"location":"cks/#6-rbac-network-policies-10","title":"6. RBAC &amp; Network Policies (10%)","text":"<ul> <li>Create <code>Role</code>, <code>ClusterRole</code>, <code>RoleBinding</code>, <code>ClusterRoleBinding</code></li> <li>Apply <code>NetworkPolicy</code> to restrict Pod traffic (ingress/egress)</li> <li>Avoid <code>*</code> verbs and <code>*</code> resources in RBAC</li> <li>Restrict access by namespace and API group</li> </ul>"},{"location":"cks/#practice-tips","title":"\u2699\ufe0f Practice Tips","text":"<ul> <li>Practice scanning + signing images:</li> <li><code>trivy image nginx:latest</code></li> <li><code>cosign sign --key cosign.key myrepo/app:1.0</code></li> <li> <p>Create test policies for:</p> <ul> <li>PSA</li> <li>RBAC + <code>kubectl auth can-i</code></li> <li>NetworkPolicy deny-by-default rules</li> </ul> </li> <li> <p>Trigger and detect audit events</p> </li> <li>Write Falco rules for suspicious behaviors</li> </ul>"},{"location":"cks/#test-environment-tips","title":"\ud83e\uddea Test Environment Tips","text":"<ul> <li> <p>Use bookmarks:</p> <ul> <li>Pod Security Standards</li> <li>Audit Logging</li> <li>Sysdig Falco</li> </ul> </li> <li> <p>Open multiple terminals: cluster work, docs lookup, test scripts</p> </li> <li>Save frequently used YAML snippets</li> </ul>"},{"location":"cks/#recommended-resources","title":"\ud83d\udcda Recommended Resources","text":"<ul> <li>Kubernetes Official Docs</li> <li>Killer.sh Simulator (CKS)</li> <li>KodeKloud CKS Course</li> <li>Linux Foundation CKS Training</li> <li>Sysdig Falco + GitHub rules</li> </ul>"},{"location":"cks/#summary","title":"Summary","text":"<p>CKS is all about applying security best practices under pressure. You\u2019ll configure audit logs, write PodSecurity controls, patch RBAC, restrict networks, and scan or sign container images - all in live clusters.</p> <p>Hands-on practice is key. Read YAML fast. Think like an attacker.</p>"},{"location":"configmaps-secrets/","title":"ConfigMaps & Secrets","text":"ConfigMaps &amp; Secrets <p>Kubernetes lets you separate your app\u2019s configuration from your container images using two special resources:</p> <ul> <li>ConfigMaps for non-sensitive data (like settings, URLs, etc.)</li> <li>Secrets for sensitive data (like passwords, tokens, certificates)</li> </ul> <p>This makes your apps more secure, portable, and easier to manage.</p> ConfigMaps (Non-Sensitive Configuration) <p>A ConfigMap is a key-value store for plain-text configuration. Use it for:</p> <ul> <li>Environment settings (like <code>LOG_LEVEL</code>, <code>API_BASE_URL</code>)</li> <li>Hostnames, ports, feature flags</li> <li>Complete config files or CLI arguments</li> </ul> Example <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  LOG_LEVEL: debug\n  DB_HOST: db.default.svc.cluster.local\n</code></pre> Secrets (Sensitive Data) <p>Secrets are also key-value stores - but for private data:</p> <ul> <li>Passwords, tokens, API keys</li> <li>SSH keys or TLS certs</li> <li>Docker registry credentials</li> </ul> <p>Kubernetes encodes all Secret values in base64 (for transport, not real security).</p> Example <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: db-secret\ntype: Opaque\ndata:\n  DB_PASSWORD: c3VwZXJzZWNyZXQ=\n</code></pre> <p>Tip</p> <p>Decode with <code>echo c3VwZXJzZWNyZXQ= | base64 -d</code>. Use <code>stringData:</code> if you want Kubernetes to handle encoding for you.</p>"},{"location":"configmaps-secrets/#ways-to-use-configmaps-and-secrets","title":"Ways to Use ConfigMaps and Secrets","text":"<p>There are three main ways to expose values inside your Pods:</p>"},{"location":"configmaps-secrets/#1-environment-variables","title":"1. Environment Variables","text":"<p>Inject all key-value pairs from a ConfigMap or Secret:</p> <pre><code>envFrom:\n  - configMapRef:\n      name: app-config\n  - secretRef:\n      name: db-secret\n</code></pre> <p>Or reference individual keys:</p> <pre><code>env:\n  - name: DB_PASSWORD\n    valueFrom:\n      secretKeyRef:\n        name: db-secret\n        key: DB_PASSWORD\n</code></pre>"},{"location":"configmaps-secrets/#2-mounted-volumes","title":"2. Mounted Volumes","text":"<p>Map each key to a file inside the container:</p> <pre><code>volumes:\n  - name: config-vol\n    configMap:\n      name: app-config\ncontainers:\n  - name: app\n    volumeMounts:\n      - name: config-vol\n        mountPath: /etc/config\n</code></pre> <p>In the container, this results in:</p> <pre><code>/etc/config/LOG_LEVEL\n/etc/config/DB_HOST\n</code></pre> <p>You can do the same for Secrets:</p> <pre><code>volumes:\n  - name: creds\n    secret:\n      secretName: db-secret\n</code></pre> <p>\u26a0\ufe0f Secrets mounted as files on disk are only base64-decoded. They are not encrypted unless you've enabled encryption at rest.</p>"},{"location":"configmaps-secrets/#3-cli-arguments-or-command-overrides","title":"3. CLI Arguments or Command Overrides","text":"<pre><code>containers:\n  - name: app\n    image: myapp\n    args:\n      - \"--log-level=$(LOG_LEVEL)\"\n    env:\n      - name: LOG_LEVEL\n        valueFrom:\n          configMapKeyRef:\n            name: app-config\n            key: LOG_LEVEL\n</code></pre> Using ConfigMaps &amp; Secrets <p>You can mount ConfigMaps and Secrets as environment variables or files inside your Pods. This keeps your app configuration flexible and secure.</p> Best Practices <ul> <li>Never store sensitive data in ConfigMaps. Use Secrets for anything private.</li> <li>Restrict access to Secrets using RBAC.</li> <li>Avoid hardcoding values in your manifests. Reference ConfigMaps and Secrets instead.</li> <li>Use external secret managers (like AWS Secrets Manager, HashiCorp Vault) for extra-sensitive data.</li> </ul> Summary <ul> <li>ConfigMaps: For non-sensitive, environment-specific configuration.</li> <li>Secrets: For sensitive data, encoded for transport.</li> <li>Both improve security, portability, and flexibility in your Kubernetes apps.</li> </ul>"},{"location":"daemonsets/","title":"DaemonSets","text":"Introduction to DaemonSets <p>DaemonSets are designed to manage the deployment of Pods across all nodes in a cluster. They ensure that a specific Pod is running on each node, making them ideal for system-level applications like log collectors, monitoring agents, and other node-specific services.</p> Use Cases for DaemonSets <p>DaemonSets are commonly used for:</p> <ul> <li>Log Collection: Deploying log collection agents on each node.</li> <li>Monitoring: Running monitoring agents to collect metrics from nodes.</li> <li>Networking: Managing network services like DNS or proxy servers.</li> </ul> Key Features <ul> <li>Automatic Updates: Automatically adds Pods to new nodes when they are added to the cluster.</li> <li>Selective Deployment: Can be configured to deploy Pods only to specific nodes using node selectors.</li> <li>Rolling Updates: Supports rolling updates to update Pods without downtime.</li> </ul> Managing DaemonSets <p>DaemonSets can be managed using various Kubernetes features:</p> <ul> <li>Node Selectors: Control which nodes a DaemonSet's Pods are scheduled on.</li> <li>Tolerations: Allow DaemonSet Pods to run on nodes with specific taints.</li> <li>Update Strategy: Configure rolling updates to minimize disruption.</li> </ul> Example YAML for DaemonSet <pre><code>apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: fluentd\nspec:\n  selector:\n    matchLabels:\n      name: fluentd\n  template:\n    metadata:\n      labels:\n        name: fluentd\n    spec:\n      containers:\n      - name: fluentd\n        image: fluent/fluentd:v1.11\n        resources:\n          limits:\n            memory: 200Mi\n            cpu: 100m\n      tolerations:\n      - key: \"node-role.kubernetes.io/master\"\n        operator: \"Exists\"\n        effect: \"NoSchedule\"\n</code></pre>"},{"location":"daemonsets/#best-practices","title":"Best PracticesSummary","text":"<ul> <li>Resource Management: Define resource requests and limits to ensure efficient use of node resources.</li> <li>Node Affinity: Use node affinity to control where Pods are scheduled.</li> <li>Monitor DaemonSet Health: Regularly check the status and health of DaemonSets to ensure they are running as expected.</li> <li>Scaling Considerations: Plan for scaling by understanding the resource requirements of DaemonSet Pods.</li> </ul> <ul> <li>DaemonSets ensure a Pod runs on every (or selected) node in your cluster.</li> <li>They\u2019re perfect for log collection, monitoring, and node-specific services.</li> <li>Rolling updates and node selectors give you fine-grained control.</li> </ul> <p>Best Practice: Use DaemonSets for system-level workloads that must run everywhere. For app workloads, use Deployments or StatefulSets.</p>"},{"location":"env-var/","title":"Env. Variables & Probes","text":"<p>Kubernetes allows you to configure runtime behavior of containers using environment variables, and to monitor their health using liveness and readiness probes. These features are essential for building reliable, configurable, and observable applications in the cluster.</p> Environment Variables <p>You can pass key-value pairs into containers using environment variables. These can be hardcoded, referenced from ConfigMaps, Secrets, or even dynamically derived from field references.</p>"},{"location":"env-var/#static-environment-variables","title":"Static Environment Variables","text":"<pre><code>env:\n  - name: LOG_LEVEL\n    value: \"debug\"\n</code></pre>"},{"location":"env-var/#from-configmap","title":"From ConfigMap","text":"<pre><code>envFrom:\n  - configMapRef:\n      name: app-config\n</code></pre> <p>Or individual keys:</p> <pre><code>env:\n  - name: APP_PORT\n    valueFrom:\n      configMapKeyRef:\n        name: app-config\n        key: port\n</code></pre>"},{"location":"env-var/#from-secret","title":"From Secret","text":"<pre><code>env:\n  - name: DB_PASSWORD\n    valueFrom:\n      secretKeyRef:\n        name: db-secret\n        key: password\n</code></pre>"},{"location":"env-var/#from-pod-metadata","title":"From Pod Metadata","text":"<pre><code>env:\n  - name: POD_NAME\n    valueFrom:\n      fieldRef:\n        fieldPath: metadata.name\n</code></pre>"},{"location":"env-var/#probes-overview","title":"Probes Overview","text":"<p>Kubernetes uses probes to check if a container is:</p> <ul> <li>Alive (liveness probe): Whether the app should be restarted</li> <li>Ready (readiness probe): Whether the app is ready to receive traffic</li> <li>Started (startup probe): Whether the app has finished starting up</li> </ul> <p>Each probe runs a check (HTTP request, TCP socket, or command) and takes action based on success or failure.</p>"},{"location":"env-var/#liveness-probe","title":"Liveness Probe","text":"<p>Restarts the container if the probe fails repeatedly.</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /healthz\n    port: 8080\n  initialDelaySeconds: 5\n  periodSeconds: 10\n</code></pre>"},{"location":"env-var/#readiness-probe","title":"Readiness Probe","text":"<p>Used to signal when the container is ready to receive traffic. If the probe fails, the Pod is removed from Service endpoints.</p> <pre><code>readinessProbe:\n  httpGet:\n    path: /ready\n    port: 8080\n  initialDelaySeconds: 5\n  periodSeconds: 10\n</code></pre>"},{"location":"env-var/#startup-probe","title":"Startup Probe","text":"<p>Useful for applications that take a long time to initialize. Prevents premature liveness failures during startup.</p> <pre><code>startupProbe:\n  httpGet:\n    path: /startup\n    port: 8080\n  failureThreshold: 30\n  periodSeconds: 10\n</code></pre>"},{"location":"env-var/#best-practices","title":"Best PracticesSummary","text":"<ul> <li>Use readiness probes to avoid routing traffic to unready pods.</li> <li>Use liveness probes for self-healing on deadlocks or hung apps.</li> <li>Use startup probes for slow-starting applications.</li> <li>Avoid setting <code>initialDelaySeconds</code> too low - allow the app to start first.</li> <li>Prefer HTTP or command probes for rich diagnostics.</li> <li>Avoid hardcoding values inside your images. Use environment variables, ConfigMaps, and Secrets for maximum flexibility and security.</li> </ul> <ul> <li>Environment variables make your containers configurable and portable.</li> <li>Use ConfigMaps and Secrets for dynamic or sensitive values.</li> <li>Probes help keep your apps healthy and ready for traffic.</li> </ul>"},{"location":"helm-package-management/","title":"Helm","text":"Helm <p>Helm is the package manager for Kubernetes. Helm lets you define, install, and upgrade Kubernetes applications using packages called charts. It makes deploying and managing complex apps as easy as installing an app on your phone - just use a \"chart\" and you're off to the races.</p> Benefits of Using Helm <ul> <li>Simplifies Deployment: Bundle all your resources in one chart for easy deployment.</li> <li>Versioning: Upgrade and roll back apps with a single command.</li> <li>Reuse: Share charts across teams and environments.</li> <li>Customization: Use templates and values to adapt to any setup.</li> <li>Dependency Management: Charts can depend on other charts.</li> </ul> Helm Architecture <ul> <li>Helm Client: Command-line tool for managing charts.</li> <li>Helm Server (Tiller): Only in Helm v2. In Helm v3+, the client talks directly to the Kubernetes API server (no Tiller).</li> </ul> How Helm Works <ul> <li>Charts: Collections of files describing Kubernetes resources.</li> <li>Values Files: Override default settings for different environments.</li> <li>Templates: Dynamically generate manifests.</li> <li>Releases: Each deployment of a chart is a release.</li> <li>Repositories: Collections of charts you can share and reuse.</li> </ul> Creating and Using Helm Charts Creating a Helm Chart <p>To create a new Helm chart:</p> <pre><code>helm create my-chart\n</code></pre> <p>This generates: <pre><code>my-chart/\n  Chart.yaml          # Chart metadata\n  values.yaml         # Default configuration values\n  charts/             # Dependency charts\n  templates/          # Kubernetes resource templates\n</code></pre></p> Example Chart.yaml <pre><code>apiVersion: v2\nname: my-chart\nversion: 0.1.0\ndescription: A Helm chart for Kubernetes\n</code></pre> Advanced Helm Features <ul> <li>Hooks: Allow you to run scripts at specific points in a release lifecycle.</li> <li>Lifecycle Management: Manage the lifecycle of applications with upgrade and rollback capabilities.</li> <li>Managing Dependencies: Use the <code>requirements.yaml</code> file to manage chart dependencies.</li> </ul> Customizing Helm Charts <p>Customize charts for different environments by using values files and templates to override default settings.</p>"},{"location":"helm-package-management/#best-practices","title":"Best Practices","text":"<ul> <li>Version Control: Keep your charts in version control for easy tracking and collaboration.</li> <li>Testing: Test your charts in different environments to ensure compatibility.</li> <li>Security: Regularly update your charts to include the latest security patches.</li> <li>Documentation: Provide clear documentation for using and customizing your charts.</li> </ul>"},{"location":"image-scan-sign/","title":"Image Scanning & Signing","text":"<p>Container images are one of the most common vectors for introducing vulnerabilities into Kubernetes clusters. Malicious, outdated, or misconfigured images can lead to privilege escalation, supply chain attacks, or data breaches. To address this, Kubernetes platforms and DevSecOps workflows rely on image scanning and image signing.</p> Image Scanning <p>Image scanning analyzes container images for known vulnerabilities in operating system packages, libraries, and application dependencies.</p>"},{"location":"image-scan-sign/#when-to-scan","title":"When to Scan:","text":"<ul> <li>During CI/CD before pushing to a registry</li> <li>On a schedule, as CVEs are constantly updated</li> <li>Before deployment into production clusters</li> </ul>"},{"location":"image-scan-sign/#common-tools","title":"Common Tools:","text":"Tool Type Key Features Trivy CLI / CI / Kubernetes Lightweight, fast scanner with SBOM support Grype CLI / CI Deep image scanning, good SBOM integration Clair API / Registry Integrates with container registries like Harbor Anchore CI/CD platform Policy-based scanning and reporting Aqua / Prisma / Snyk Enterprise Advanced scanning, RBAC integration, UI dashboards"},{"location":"image-scan-sign/#example-scanning-with-trivy","title":"Example: Scanning with Trivy","text":"<pre><code>trivy image nginx:1.21\n</code></pre> <p>This command checks for CVEs in the <code>nginx:1.21</code> image and provides severity breakdowns and remediation guidance.</p>"},{"location":"image-scan-sign/#image-signing","title":"Image Signing","text":"<p>Image signing ensures the authenticity and integrity of container images. Signed images can be verified before they are pulled or deployed to ensure they haven\u2019t been tampered with.</p> <p>Signing involves: 1. Creating a cryptographic signature for an image 2. Attaching it to the image metadata or registry 3. Verifying the signature during admission or runtime</p>"},{"location":"image-scan-sign/#tools","title":"Tools:","text":"Tool Purpose Notes cosign Signing and verifying OCI images Lightweight and integrates with Sigstore Notary v2 Signing framework (Docker 2.0) Upcoming standard for OCI image signing Sigstore Ecosystem for supply chain trust Powers cosign, keyless signing, policy"},{"location":"image-scan-sign/#example-signing-and-verifying-with-cosign","title":"Example: Signing and Verifying with cosign","text":"<pre><code># Sign the image\ncosign sign ghcr.io/example/image:tag\n\n# Verify the image signature\ncosign verify ghcr.io/example/image:tag\n</code></pre> <p>Cosign supports keyless signing using identity providers like GitHub Actions or OIDC credentials.</p>"},{"location":"image-scan-sign/#enforcing-signed-images","title":"Enforcing Signed Images","text":"<p>Signed images can be enforced at admission time using:</p> <ul> <li>Kyverno: Policy engine that can block unsigned or unverified images</li> <li>OPA Gatekeeper: Rego-based policies for image trust</li> <li>Sigstore Policy Controller: Native support for verifying signatures on admission</li> </ul>"},{"location":"image-scan-sign/#example-kyverno-policy-snippet","title":"Example: Kyverno Policy Snippet","text":"<pre><code>apiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: verify-image-signatures\nspec:\n  validationFailureAction: enforce\n  rules:\n  - name: require-signed-images\n    match:\n      resources:\n        kinds:\n        - Pod\n    validate:\n      message: \"Image must be signed with cosign.\"\n      pattern:\n        spec:\n          containers:\n          - image: \"*\"\n            imagePullPolicy: \"Always\"\n</code></pre>"},{"location":"image-scan-sign/#best-practices","title":"Best Practices","text":"<ul> <li>Integrate scanning into CI/CD pipelines to catch issues early</li> <li>Continuously monitor for newly discovered CVEs</li> <li>Use image signing to enforce trusted provenance</li> <li>Regularly rotate signing keys and scan SBOMs (Software Bill of Materials)</li> <li>Avoid <code>:latest</code> tags - use immutable, versioned image references</li> </ul>"},{"location":"image-scan-sign/#summary","title":"Summary","text":"<p>Scanning and signing container images are critical steps in securing your Kubernetes supply chain. Scanning prevents vulnerable software from being deployed, while signing ensures you're running trusted, unmodified images. Together, they help protect your workloads from tampering and known exploits, forming the foundation of modern Kubernetes security.</p>"},{"location":"init-containers/","title":"Init Containers","text":"<p>Init containers run before regular containers in a Pod start. They\u2019re designed to perform setup tasks that need to complete before your main application launches - like setting config values, creating folders, or waiting for external services.</p> Why Use Init Containers? <ul> <li>Wait for a database or service to become available</li> <li>Download configuration or secrets from an external source</li> <li>Run database migrations or setup scripts</li> <li>Perform one-time initialization logic before the main app starts</li> </ul> <p>Init containers always run to completion before normal containers are started. If an init container fails, the Pod restarts and tries again.</p>"},{"location":"init-containers/#lifecycle-flow","title":"Lifecycle Flow","text":"<pre><code>flowchart TD\n  start_pod --&gt; init_containers\n  init_containers --&gt; init_success\n  init_success --&gt; main_containers\n\n  start_pod[Start Pod]\n  init_containers[Run Init Containers]\n  init_success[Init Success]\n  main_containers[Run Main Containers]\n</code></pre> <ul> <li>If any init container fails, Kubernetes restarts the entire Pod.</li> <li>Init containers run sequentially, not in parallel.</li> <li>Once completed, they\u2019re never run again.</li> </ul>"},{"location":"init-containers/#example-init-container-waiting-for-service","title":"Example: Init Container Waiting for ServiceKey Differences vs Regular ContainersSummary","text":"<pre><code>initContainers:\n  - name: wait-for-db\n    image: busybox\n    command: ['sh', '-c', 'until nc -z db 5432; do sleep 2; done']\n</code></pre> <p>This init container waits for a database service to be reachable on port 5432 before allowing the main container to start.</p> Feature Init Container App Container Runs before main app \u2705 \u274c Runs once per Pod \u2705 \u274c Can block Pod startup \u2705 \u274c Restarts separately \u274c (triggers Pod restart) \u2705 <p>Init containers are a built-in way to prepare your environment before your app runs. They help keep your main containers focused and clean by offloading setup logic. Use them to wait on dependencies, perform one-time actions, or enforce startup ordering.</p> <ul> <li>Init containers run before your main app, handling setup and dependencies.</li> <li>Use them for waiting on services, running migrations, or any pre-launch logic.</li> <li>They run sequentially and must succeed before your main containers start.</li> </ul>"},{"location":"jobs-cronjobs/","title":"Jobs & Cronjobs","text":"Jobs &amp; CronJobs <p>Not all Kubernetes workloads run forever. Sometimes, you just need to run something once - or on a schedule. That\u2019s where Jobs and CronJobs come in.</p> Jobs <p>A Job runs a Pod (or Pods) to completion. Perfect for: - One-time tasks - Batch processing - Migrations or post-deployment hooks</p> <p>Kubernetes guarantees the Job runs to completion - even if a Pod crashes or a node fails, a new Pod will be scheduled.</p> Minimal Job Example <pre><code>kind: Job\nspec:\n  template:\n    spec:\n      containers:\n        - name: hello\n          image: busybox\n          command: [\"echo\", \"Hello World\"]\n      restartPolicy: Never\n</code></pre> <p>Tip: The <code>restartPolicy</code> for Jobs must be <code>Never</code> or <code>OnFailure</code>.</p> CronJobs <p>A CronJob runs Jobs on a repeating schedule, just like Linux cron.</p> <p>Use CronJobs for: - Periodic cleanup tasks - Scheduled reports - Time-based batch jobs</p> Cron Syntax Example <pre><code>kind: CronJob\nspec:\n  schedule: \"0 * * * *\"  # every hour\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n            - name: task\n              image: busybox\n              args: [\"echo\", \"Hourly job\"]\n          restartPolicy: OnFailure\n</code></pre> <p>CronJobs use the same <code>jobTemplate</code> spec as regular Jobs.</p>"},{"location":"jobs-cronjobs/#cron-syntax-quick-guide","title":"Cron Syntax Quick Guide","text":"Field Meaning Minute 0\u201359 Hour 0\u201323 Day of Month 1\u201331 Month 1\u201312 Day of Week 0\u20136 (Sun=0) <p>Examples: - <code>0 0 * * *</code> = Every day at midnight - <code>*/5 * * * *</code> = Every 5 minutes</p>"},{"location":"jobs-cronjobs/#summary","title":"Summary","text":"<ul> <li>Use a Job for tasks that need to run once and finish.</li> <li>Use a CronJob to schedule Jobs using cron syntax.</li> <li>Both are useful for batch jobs, cleanup scripts, and other non-service workloads.</li> </ul>"},{"location":"kubectl-cheatsheet/","title":"Kubectl Cheat Sheet","text":"<p>A comprehensive command reference for everyday Kubernetes use - cleaner, deeper, and more practical than the standard cheat sheets.</p>"},{"location":"kubectl-cheatsheet/#context-configuration","title":"\ud83d\udd27 Context &amp; Configuration","text":"Command Description <code>kubectl config get-contexts</code> List all contexts <code>kubectl config use-context &lt;context&gt;</code> Switch to a different context <code>kubectl config current-context</code> Show the active context <code>kubectl config view --minify</code> View config of current context <code>kubectl config set-context</code> Create or modify a context <code>kubectl config set-cluster</code> Set a cluster config <code>kubectl config set-credentials</code> Configure user credentials <code>kubectl config unset users.&lt;user&gt;</code> Remove a user from config"},{"location":"kubectl-cheatsheet/#pods","title":"\ud83d\udce6 Pods","text":"Command Description <code>kubectl get pods</code> List all pods in current namespace <code>kubectl get pods -A</code> List pods across all namespaces <code>kubectl get pod &lt;name&gt; -o wide</code> Show pod details including IP and node <code>kubectl describe pod &lt;name&gt;</code> Detailed pod information <code>kubectl logs &lt;pod&gt;</code> Logs from main container <code>kubectl logs &lt;pod&gt; -c &lt;container&gt;</code> Logs from a specific container <code>kubectl exec -it &lt;pod&gt; -- /bin/sh</code> Open shell session in pod <code>kubectl delete pod &lt;pod&gt;</code> Delete a pod (useful for restart)"},{"location":"kubectl-cheatsheet/#deployments","title":"\ud83d\ude80 Deployments","text":"Command Description <code>kubectl get deploy</code> List deployments <code>kubectl describe deploy &lt;name&gt;</code> View deployment details <code>kubectl scale deploy &lt;name&gt; --replicas=3</code> Scale deployment <code>kubectl rollout status deploy &lt;name&gt;</code> Track rollout progress <code>kubectl rollout history deploy &lt;name&gt;</code> Show rollout history <code>kubectl rollout undo deploy &lt;name&gt;</code> Roll back to previous revision <code>kubectl edit deploy &lt;name&gt;</code> Edit deployment in-place <code>kubectl delete deploy &lt;name&gt;</code> Delete a deployment"},{"location":"kubectl-cheatsheet/#services","title":"\ud83d\udccb Services","text":"Command Description <code>kubectl get svc</code> List services <code>kubectl describe svc &lt;name&gt;</code> Detailed service info <code>kubectl expose pod nginx --port=80 --type=ClusterIP</code> Expose pod as service <code>kubectl port-forward svc/&lt;svc&gt; 8080:80</code> Forward local port to service <code>kubectl get endpoints</code> Show service endpoints"},{"location":"kubectl-cheatsheet/#ingress","title":"\ud83c\udf10 Ingress","text":"Command Description <code>kubectl get ingress</code> List ingress resources <code>kubectl describe ingress &lt;name&gt;</code> Details of an ingress resource"},{"location":"kubectl-cheatsheet/#configmaps-secrets","title":"\ud83d\udce6 ConfigMaps &amp; Secrets","text":"Command Description <code>kubectl get configmap</code> List ConfigMaps <code>kubectl create configmap &lt;name&gt; --from-literal=key=value</code> Create from literal <code>kubectl create configmap &lt;name&gt; --from-file=file.txt</code> Create from file <code>kubectl get secret</code> List Secrets <code>kubectl create secret generic &lt;name&gt; --from-literal=password=secret</code> Create basic secret <code>kubectl get secret &lt;name&gt; -o yaml</code> View base64-encoded secret <code>kubectl get secret &lt;name&gt; -o jsonpath=\"{.data.key}\" \\| base64 -d</code> Decode a secret"},{"location":"kubectl-cheatsheet/#rbac-serviceaccounts","title":"\ud83d\udd10 RBAC &amp; ServiceAccounts","text":"Command Description <code>kubectl create sa &lt;name&gt;</code> Create a ServiceAccount <code>kubectl get sa</code> List ServiceAccounts <code>kubectl get clusterrolebinding -A</code> List all ClusterRoleBindings <code>kubectl describe clusterrolebinding &lt;name&gt;</code> Show details of binding <code>kubectl auth can-i get pods --as=system:serviceaccount:ns:sa</code> Check access for a ServiceAccount"},{"location":"kubectl-cheatsheet/#namespaces","title":"\ud83d\udcc2 Namespaces","text":"Command Description <code>kubectl get ns</code> List namespaces <code>kubectl create ns &lt;name&gt;</code> Create a namespace <code>kubectl delete ns &lt;name&gt;</code> Delete a namespace <code>kubectl config set-context --current --namespace=&lt;ns&gt;</code> Set default namespace for current context"},{"location":"kubectl-cheatsheet/#jobs-cronjobs","title":"\ud83d\udee0 Jobs &amp; CronJobs","text":"Command Description <code>kubectl create job hello --image=busybox -- echo Hello</code> Run one-time job <code>kubectl get jobs</code> List jobs <code>kubectl delete job &lt;name&gt;</code> Delete a job <code>kubectl create cronjob hello --image=busybox --schedule=\"*/5 * * * *\" -- echo Hi</code> Schedule recurring job <code>kubectl get cronjob</code> List CronJobs"},{"location":"kubectl-cheatsheet/#storage-pvs-pvcs","title":"\ud83d\udce6 Storage (PVs &amp; PVCs)","text":"Command Description <code>kubectl get pv</code> List PersistentVolumes <code>kubectl get pvc</code> List PersistentVolumeClaims <code>kubectl describe pvc &lt;name&gt;</code> PVC details <code>kubectl delete pvc &lt;name&gt;</code> Delete a PVC"},{"location":"kubectl-cheatsheet/#debugging-troubleshooting","title":"\ud83d\udd0d Debugging &amp; Troubleshooting","text":"Command Description <code>kubectl get events --sort-by=.metadata.creationTimestamp</code> Show recent events <code>kubectl logs &lt;pod&gt; --previous</code> Logs from a crashed pod <code>kubectl exec -it &lt;pod&gt; -- /bin/sh</code> Open shell in pod <code>kubectl debug -it &lt;pod&gt; --image=busybox --target=&lt;container&gt;</code> Ephemeral debug container <code>kubectl top pod</code> Show pod CPU/memory usage <code>kubectl get pods -o wide</code> Show node assignments and IPs"},{"location":"kubectl-cheatsheet/#yaml-apply","title":"\ud83d\udce4 YAML &amp; Apply","text":"Command Description <code>kubectl apply -f &lt;file&gt;.yaml</code> Apply a YAML manifest <code>kubectl delete -f &lt;file&gt;.yaml</code> Delete resource defined in YAML <code>kubectl apply -f &lt;file&gt;.yaml --dry-run=client -o yaml</code> Preview resource definition <code>kubectl explain &lt;resource&gt;</code> Show schema for a resource"},{"location":"kubectl-cheatsheet/#output-formatting","title":"\ud83d\udcca Output Formatting","text":"Command Description <code>-o wide</code> Show more details (e.g. IPs, nodes) <code>-o yaml</code> Output full YAML <code>-o jsonpath=\"{.items[*].metadata.name}\"</code> Query JSON paths <code>--field-selector status.phase=Running</code> Filter by field <code>-l app=nginx</code> Filter by label <code>--sort-by=.metadata.name</code> Sort output"},{"location":"kubectl-cheatsheet/#port-forwarding-proxies","title":"\ud83d\udd01 Port Forwarding &amp; Proxies","text":"Command Description <code>kubectl port-forward pod/&lt;pod&gt; 8080:80</code> Port forward to pod <code>kubectl port-forward svc/&lt;svc&gt; 9090:80</code> Port forward to service <code>kubectl proxy</code> Run API proxy at localhost:8001"},{"location":"kubectl-cheatsheet/#cleanup-deletion","title":"\ud83e\uddfc Cleanup &amp; Deletion","text":"Command Description <code>kubectl delete all --all</code> Delete all resources in namespace <code>kubectl delete pod,svc -l app=nginx</code> Delete resources by label <code>kubectl delete pvc --all</code> Remove all PVCs"},{"location":"kubectl-cheatsheet/#common-shortcuts","title":"\ud83e\uddea Common Shortcuts","text":"Task Command Restart a pod <code>kubectl delete pod &lt;pod&gt;</code> (Deployment auto-recreates) Watch pod status <code>watch kubectl get pods</code> Quick deploy NGINX <code>kubectl create deploy nginx --image=nginx</code> Expose NGINX <code>kubectl expose deploy nginx --port=80 --type=LoadBalancer</code>"},{"location":"kubernetes-api/","title":"Kubernetes API","text":"<p>The Kubernetes API is the primary interface to interact with your cluster. Whether you\u2019re deploying an app, scaling a workload, inspecting a Pod, or running automation - you\u2019re using the Kubernetes API.</p> <p>It\u2019s declarative, versioned, extensible, and serves as the backbone of the control plane.</p> What Is the Kubernetes API? <p>At its core, the API is a RESTful interface that lets you manage API objects such as:</p> <ul> <li>Pods</li> <li>Deployments</li> <li>Services</li> <li>ConfigMaps</li> <li>Namespaces</li> <li>Custom Resources (via CRDs)</li> </ul> <p>Everything in Kubernetes - from <code>kubectl</code> to the scheduler - interacts with the API server.</p> Anatomy of a Kubernetes Object <p>Every resource in Kubernetes follows a common structure:</p> <pre><code>apiVersion: apps/v1          # API group + version\nkind: Deployment             # Type of object\nmetadata:\n  name: my-app\n  namespace: default\nspec:                        # Desired state (defined by user)\n  replicas: 2\nstatus:                      # Actual state (set by the system)\n  replicas: 2\n</code></pre> Field Description <code>apiVersion</code> Group/version the object belongs to <code>kind</code> The object type (e.g., <code>Pod</code>, <code>Service</code>) <code>metadata</code> Info like name, namespace, labels, annotations <code>spec</code> The desired configuration (user-defined) <code>status</code> The actual observed state (set by controllers) API Server Role <p>The <code>kube-apiserver</code> is the front door to your cluster. It handles:</p> <ul> <li>All incoming requests from users, <code>kubectl</code>, controllers, and web UIs</li> <li>Validation of requests and schemas</li> <li>Authentication &amp; Authorization</li> <li>Admission control</li> <li>Persisting cluster state in <code>etcd</code></li> </ul> <p>It's stateless and horizontally scalable - multiple API server instances can run behind a load balancer.</p>"},{"location":"kubernetes-api/#api-request-lifecycle","title":"API Request Lifecycle","text":"<pre><code>flowchart TD\n  A([kubectl apply -f deployment.yaml]) --&gt; B([kube-apiserver])\n  B --&gt; C([Auth \u2b62 RBAC \u2b62 Admission Controllers])\n  C --&gt; D([etcd - stores desired state])\n  D --&gt; E([Controller Manager watches &amp; reacts])\n  E --&gt; F([Scheduler places Pod on Node])\n  F --&gt; G([kubelet starts container])</code></pre>"},{"location":"kubernetes-api/#api-groups-versions","title":"API Groups &amp; Versions","text":"<p>Kubernetes organizes APIs into groups and versions.</p> Path Prefix Group Name Used For <code>/api/v1</code> Core (no group name) Pods, ConfigMaps, Services <code>/apis/apps/v1</code> <code>apps</code> group Deployments, StatefulSets <code>/apis/batch/v1</code> <code>batch</code> group Jobs, CronJobs <code>/apis/networking.k8s.io/v1</code> Networking group Ingress, NetworkPolicies <code>/apis/custom.group/v1</code> Custom Resource group CRDs, Operators <p>You can discover all groups and versions with:</p> <pre><code>kubectl api-versions\nkubectl api-resources\n</code></pre>"},{"location":"kubernetes-api/#crud-via-kubectl","title":"CRUD via kubectl","text":"<p><code>kubectl</code> is a CLI wrapper over raw HTTP requests to the API. Examples:</p> Action HTTP Equivalent <code>kubectl get pods</code> <code>GET /api/v1/namespaces/default/pods</code> <code>kubectl apply -f file.yaml</code> <code>PATCH</code> or <code>POST</code> to relevant endpoint <code>kubectl delete pod nginx</code> <code>DELETE /api/v1/namespaces/default/pods/nginx</code>"},{"location":"kubernetes-api/#declarative-vs-imperative","title":"Declarative vs Imperative","text":"<ul> <li>Imperative: You tell Kubernetes how to do something (<code>kubectl run</code>, <code>kubectl expose</code>)</li> <li>Declarative: You define the desired state, and the system reconciles (<code>kubectl apply -f</code>)</li> </ul> <p>Kubernetes is fundamentally declarative - the controller manager continually works to match the actual state to the desired state.</p>"},{"location":"kubernetes-api/#working-with-the-api-directly","title":"Working with the API Directly","text":"<p>Enable the API proxy:</p> <pre><code>kubectl proxy\n</code></pre> <p>Browse live cluster data in your browser: http://localhost:8001/api</p> <p>Also try:</p> <pre><code>curl http://localhost:8001/api/v1/namespaces/default/pods\n</code></pre>"},{"location":"kubernetes-api/#custom-resource-definitions-crds","title":"Custom Resource Definitions (CRDs)","text":"<p>CRDs allow you to extend the Kubernetes API with your own types.</p> <p>Example:</p> <pre><code>apiVersion: myteam.example.com/v1\nkind: Widget\nmetadata:\n  name: widget-123\nspec:\n  color: blue\n  size: large\n</code></pre> <p>This adds a new resource (<code>Widget</code>) to the cluster. Common in Operators.</p>"},{"location":"kubernetes-api/#api-security-flow","title":"API Security FlowSummary","text":"<p>Every API request goes through:</p> <ol> <li>Authentication \u2013 Who is making the request?</li> <li>Authorization (RBAC) \u2013 Are they allowed to perform this action?</li> <li>Admission Controllers \u2013 Mutate or validate the request</li> <li>Validation \u2013 Is the object schema correct?</li> <li>Persistence \u2013 If approved, store in etcd</li> </ol> <ul> <li>The Kubernetes API is the backbone of your cluster-everything goes through it.</li> <li>All operations, from deploying apps to inspecting resources, use the API.</li> <li>Understanding the API is key to mastering Kubernetes automation and troubleshooting.</li> </ul> <p>Tip</p> <p>Use <code>kubectl explain &lt;resource&gt;</code> and the official API docs to understand all available fields and options.</p>"},{"location":"limits-requests/","title":"Limits & Requests","text":"Resource Requests &amp; Limits <p>Kubernetes lets you control how much CPU and memory each container is guaranteed and allowed to use. This is done through resource requests and limits in the container spec.</p> Requests vs Limits Term Purpose Scheduler Uses? Enforced at Runtime? <code>requests</code> Minimum resources guaranteed to a container \u2705 Yes \u274c No <code>limits</code> Maximum resources a container can use \u274c No \u2705 Yes <ul> <li>Requests are used during scheduling. Kubernetes places Pods on nodes that can satisfy their requested resources.</li> <li>Limits prevent a container from exceeding a set threshold.</li> </ul> Example: CPU and Memory Settings <pre><code>resources:\n  requests:\n    memory: \"256Mi\"\n    cpu: \"250m\"\n  limits:\n    memory: \"512Mi\"\n    cpu: \"500m\"\n</code></pre> <p>This guarantees the container gets at least 256Mi and 250 millicores, but it cannot exceed 512Mi or 500 millicores.</p> Why It Matters <ul> <li>Too low requests \u2192 Your Pod may get scheduled on a crowded node and experience performance issues.</li> <li>No limits \u2192 A container can consume all resources and cause noisy neighbor problems.</li> <li>Too low limits \u2192 Can result in OOMKills or throttled CPU.</li> </ul> CPU Behavior <ul> <li>If a container exceeds its CPU limit, it is throttled - not killed.</li> <li>If you don\u2019t set a limit, the container may consume all available CPU.</li> </ul> Memory Behavior <ul> <li>If memory usage exceeds the limit, the container is killed with an OOMKill (Out of Memory).</li> <li>Kubernetes does not restart it unless it's part of a higher-level controller (like a Deployment).</li> </ul> Best Practices <ul> <li>Always set both requests and limits - especially for memory.</li> <li>Set realistic requests to ensure proper scheduling.</li> <li>Avoid overly restrictive limits unless you're debugging or need to enforce strict control.</li> <li>Use LimitRanges to enforce defaults and maximums in namespaces.</li> <li>Monitor Pod and Node usage to tune your settings.</li> <li>Set realistic requests and limits for every container. This keeps your cluster healthy and prevents resource hogs or accidental outages.</li> </ul> Summary <ul> <li>Requests guarantee a minimum amount of resources for a container.</li> <li>Limits cap the maximum resources a container can use.</li> <li>Always set both for predictable, stable workloads.</li> </ul>"},{"location":"local-setup/","title":"Local setup","text":""},{"location":"local-setup/#getting-a-local-kubernetes-cluster","title":"Getting a Local Kubernetes Cluster","text":"<p>For most users, setting up a local Kubernetes cluster using Docker Desktop or KinD (Kubernetes in Docker) is the best option when learning. It's free and allows you to quickly and easily get your hands on and start playing with Kubernetes.</p> Option 1: Docker Desktop <p>Docker Desktop is a straightforward way to get Docker, Kubernetes, and <code>kubectl</code> on your computer, along with a user-friendly interface for managing your cluster contexts.</p> <p>Install Docker Desktop:</p> <p>Download and run the installer for your operating system from the Docker website. Follow the installation prompts. For Windows users, install the WSL 2 subsystem when prompted.</p> <p>Enable Kubernetes in Docker Desktop:</p> <p>Click the Docker icon in your menu bar or system tray and go to Settings. Select \"Kubernetes\" from the left navigation bar. Check \"Enable Kubernetes\" and click \"Apply &amp; restart.\" Wait a few minutes for Docker Desktop to pull the required images and start the cluster. The Kubernetes icon in the Docker Desktop window will turn green when the cluster is ready.</p> <p>Verify the Installation:</p> <p>Open a terminal and run the following commands to ensure Docker and <code>kubectl</code> are installed and working:</p> <pre><code>docker --version\nkubectl version --client=true -o yaml\n</code></pre> <p>Ensure the cluster is running with:</p> <p><pre><code>kubectl get nodes\n</code></pre> This command lists all the nodes in your Kubernetes cluster. You should see at least one node listed, confirming your cluster is up and running.</p> Option 2: KinD <p>KinD (Kubernetes in Docker) is an excellent tool for running local Kubernetes clusters using Docker containers. It\u2019s lightweight, flexible, and ideal for development and testing. It's my tool of choice for local development/experimentation.</p> <p>Install KinD:</p> <p>Follow the instructions on the KinD GitHub page to install KinD on your system. For macOS users, you can simply run <code>brew install kind</code> to get up and running quickly.</p> <p>Create a KinD Cluster:</p> <p><pre><code>kind create cluster\n</code></pre> This command sets up a new Kubernetes cluster locally using Docker containers. KinD creates a single-node cluster by default, which is sufficient for most development and testing needs.</p> <p>Verify your cluster is running:</p> <p><pre><code>kubectl get nodes\n</code></pre> This command lists all the nodes in your Kubernetes cluster. You should see the node created by KinD, confirming your cluster is up and running.</p> Alternative Tools <p>While Docker Desktop and KinD are popular choices, other tools like Minikube or k3d can also be used to set up local Kubernetes clusters. These tools offer different features and may better suit specific needs or preferences.</p>"},{"location":"local-setup/#working-with-kubectl","title":"Working with kubectl","text":"<p><code>kubectl</code> is the command-line tool used to interact with your Kubernetes clusters. It's essential for deploying applications, inspecting and managing cluster resources, and troubleshooting issues.</p> Installation <p>If you've followed the steps to set up either Docker Desktop or KinD, you should already have <code>kubectl</code> installed. If not, you can install it separately:</p> <p>Linux:</p> <pre><code>curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nchmod +x kubectl\nsudo mv kubectl /usr/local/bin/\n</code></pre> <p>Mac:</p> <pre><code>brew install kubectl\n</code></pre> <p>Windows:</p> <p>Download the executable from the official Kubernetes site and add it to your system PATH.</p> Using kubectl <p>Once installed, <code>kubectl</code> allows you to perform various operations on your Kubernetes cluster. Here are a few basic commands to get you started:</p> <p>Check Cluster Nodes: <pre><code>kubectl get nodes\n</code></pre> This command lists all nodes in the cluster, showing their status, roles, and other details.</p> <p>Get Cluster Info: <pre><code>kubectl cluster-info\n</code></pre> This command displays information about the cluster, including the URL of the Kubernetes master and other components.</p> <p>Deploy an Application: <pre><code>kubectl apply -f &lt;filename&gt;.yaml\n</code></pre> This command applies a configuration file to the cluster, creating or updating resources defined in the file.</p> <p>Inspect Resources: <pre><code>kubectl get pods\nkubectl describe pod &lt;pod-name&gt;\n</code></pre> These commands list all pods in the cluster and provide detailed information about a specific pod, respectively.</p> Setting an Alias for kubectl <p>Instead of typing out <code>kubectl</code> for every command, many Kubernetes users set an alias for it by adding the following to their shell profile:</p> <p><pre><code>alias k=kubectl\n</code></pre> This way, you can use <code>k</code> instead of <code>kubectl</code> in your commands, saving time and effort.</p> <p>Tip</p> <p>Using aliases can significantly speed up your workflow and reduce the chances of making typos in long commands.</p>"},{"location":"local-setup/#summary","title":"Summary","text":"<p>Setting up a local Kubernetes cluster using Docker Desktop or KinD is a great way to get hands-on experience with Kubernetes. Both tools provide an easy and quick way to start working with Kubernetes, allowing you to experiment and learn in a controlled environment. With <code>kubectl</code>, you can manage your cluster and deploy applications, making it an essential tool for any Kubernetes user.</p>"},{"location":"maintenance/","title":"Maintenance","text":"Kubernetes Maintenance <p>Regular maintenance is essential for ensuring the stability and performance of your Kubernetes clusters. This section covers key maintenance activities, including upgrading clusters, nodes, Kubernetes versions, and operating systems.</p> Upgrading Kubernetes Clusters Cluster Upgrades <p>Upgrading your Kubernetes cluster ensures you have the latest features, security patches, and performance improvements.</p> <ol> <li> <p>Plan the Upgrade</p> <ul> <li>Review release notes and determine upgrade path.</li> <li>Backup critical data and verify integrity.</li> <li>Test the upgrade process in a staging environment.</li> </ul> </li> <li> <p>Perform the Upgrade</p> <ul> <li>Follow your Kubernetes distribution's upgrade documentation.</li> <li>Monitor the upgrade process and be ready to roll back if needed.</li> </ul> </li> </ol> Node Upgrades <ol> <li> <p>Prepare Nodes</p> <ul> <li>Drain nodes using <code>kubectl drain &lt;node-name&gt;</code>.</li> <li>Upgrade Kubernetes components and OS packages.</li> </ul> </li> <li> <p>Rejoin Cluster</p> <ul> <li>Use <code>kubectl uncordon &lt;node-name&gt;</code> to bring nodes back online.</li> </ul> </li> </ol>"},{"location":"maintenance/#upgrading-kubernetes-versions","title":"Upgrading Kubernetes VersionsBest PracticesSummaryAdditional Resources","text":"<ol> <li> <p>Check Compatibility</p> <ul> <li>Review the version skew policy to ensure compatibility across your environment.</li> <li>Review deprecated features and update manifests.</li> <li>Test applications in a staging environment.</li> </ul> </li> <li> <p>Upgrade Control Plane and Nodes</p> <ul> <li>Follow official Kubernetes documentation for upgrading components.</li> <li>Upgrade <code>kubelet</code> and <code>kubectl</code> on nodes.</li> </ul> </li> </ol> <ul> <li>Regularly audit cluster configurations and security settings.</li> <li>Document maintenance activities and changes.</li> <li>Implement automated backup solutions to protect critical data.</li> </ul> <p>Regular maintenance is crucial for the stability and performance of your Kubernetes clusters. By following the best practices outlined in this guide, you can ensure your clusters are up-to-date, secure, and running smoothly.</p> <p>For more information on Kubernetes maintenance, refer to the official Kubernetes documentation.</p>"},{"location":"namespaces/","title":"Namespaces","text":"Namespaces <p>Namespaces in Kubernetes allow you to divide cluster resources between multiple users or teams. They provide logical isolation and help with multi-tenancy, access control, and resource management.</p> When to Use Namespaces <p>Namespaces are useful when:</p> <ul> <li>You need to isolate environments (e.g., <code>dev</code>, <code>staging</code>, <code>prod</code>)</li> <li>You want to enforce resource quotas and limits</li> <li>You want to implement RBAC per team or application</li> </ul> <p>Tip</p> <p>For most small or single-team clusters, the <code>default</code> namespace is sufficient.</p> Viewing Namespaces <pre><code>kubectl get namespaces\n</code></pre> <p>Or with shorthand:</p> <pre><code>kubectl get ns\n</code></pre> Creating a Namespace <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: dev-team\n</code></pre> <p>Apply it:</p> <pre><code>kubectl apply -f namespace.yaml\n</code></pre> Using Namespaces with kubectl <pre><code>kubectl get pods -n dev-team\nkubectl create deployment nginx --image=nginx -n dev-team\n</code></pre> <p>To temporarily switch namespace context:</p> <pre><code>kubectl config set-context --current --namespace=dev-team\n</code></pre>"},{"location":"namespaces/#default-namespaces","title":"Default Namespaces","text":"Namespace Purpose <code>default</code> Used when no other namespace is specified <code>kube-system</code> Kubernetes control plane components (DNS, scheduler) <code>kube-public</code> Readable by all users, often used for public bootstrap <code>kube-node-lease</code> Heartbeats for node status"},{"location":"namespaces/#namespaced-vs-cluster-scoped-resources","title":"Namespaced vs Cluster-Scoped Resources","text":"<p>Some resources must live in a namespace, others are cluster-scoped.</p> Namespaced Cluster-Scoped Pods, Deployments, PVCs Nodes, PersistentVolumes ConfigMaps, Secrets Namespaces, CRDs Services StorageClasses, RBAC Roles"},{"location":"namespaces/#resource-quotas-and-limits","title":"Resource Quotas and LimitsSummary","text":"<p>You can enforce limits on namespaces using:</p> <ul> <li><code>ResourceQuota</code>: caps total resources in the namespace</li> <li><code>LimitRange</code>: sets default limits per Pod/container</li> </ul> <p>Example:</p> <pre><code>apiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: compute-quota\n  namespace: dev\nspec:\n  hard:\n    requests.cpu: \"2\"\n    limits.memory: 4Gi\n</code></pre> <ul> <li>Namespaces provide logical isolation for teams, environments, or applications.</li> <li>Use namespaces to set resource quotas, apply RBAC, and organize your cluster.</li> <li>For small/simple clusters, the <code>default</code> namespace is fine; use more as you scale.</li> </ul> <p>Tip</p> <p>Name namespaces clearly (e.g., <code>dev</code>, <code>prod</code>, <code>team-a</code>) and use them to enforce security and resource policies.</p> <p></p>"},{"location":"netpol/","title":"Network Policies","text":"Network Policies <p>By default, all Pods in a Kubernetes cluster can talk to each other. This is convenient, but risky - especially in multi-tenant clusters or production environments.</p> <p>NetworkPolicies let you control which Pods can talk to which other Pods (and even external IPs).</p> <p>Think of it like a firewall for Pod-to-Pod traffic - but defined in YAML.</p> Key Concepts <ul> <li>NetworkPolicies apply to Pods (via label selectors)</li> <li>They control ingress, egress, or both</li> <li>They require a network plugin (CNI) that supports them (e.g., Calico, Cilium)</li> </ul> <p>No policies = allow all Any policy = default deny (for the targeted direction)</p> Minimal Example <p>Allow only traffic to a Pod from Pods with a specific label:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-frontend\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: backend\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: frontend\n</code></pre> <p>This says:  only Pods labeled <code>app=frontend</code> can access Pods labeled <code>app=backend</code>.</p> Policy Scope Field Controls <code>podSelector</code> Which Pods the policy applies to <code>ingress</code> Who can reach the Pod <code>egress</code> Where the Pod is allowed to send traffic"},{"location":"netpol/#egress-example","title":"Egress Example","text":"<pre><code>egress:\n  - to:\n      - ipBlock:\n          cidr: 10.0.0.0/24\n    ports:\n      - protocol: TCP\n        port: 443\n</code></pre> <p>This allows outbound HTTPS traffic only to <code>10.0.0.0/24</code>.</p>"},{"location":"netpol/#tips-gotchas","title":"Tips &amp; Gotchas","text":"<ul> <li>If a Pod is not selected by any policy, it is open by default</li> <li>If a Pod is selected, and you define <code>ingress</code>, all other traffic is denied</li> <li>You must allow DNS explicitly if you restrict egress (e.g., UDP 53)</li> <li>Labels matter  -  both on the target and the allowed sources</li> </ul>"},{"location":"netpol/#cni-support","title":"CNI SupportSummary","text":"<p>Not all network plugins support NetworkPolicies. Some common ones that do:</p> <ul> <li>\u2705 Calico</li> <li>\u2705 Cilium</li> <li>\u2705 Antrea</li> <li>\u274c Flannel (without plugins)</li> <li>\u274c Amazon VPC CNI (limited support unless enhanced)</li> </ul> <ul> <li>NetworkPolicies let you control pod-to-pod and pod-to-external communication.</li> <li>By default, all traffic is allowed - add a policy to restrict.</li> <li>Use label selectors to target specific Pods for fine-grained control.</li> <li>NetworkPolicies control Pod-level traffic based on labels and CIDRs</li> <li>Define who can talk to what, and where traffic can go</li> <li>Essential for zero-trust network design inside the cluster</li> <li>Start with <code>ingress</code> rules, then layer on <code>egress</code> if needed</li> </ul>"},{"location":"networking/","title":"Networking Overview","text":"Networking Overview <p>Networking in Kubernetes is simple on the surface, but powerful under the hood. Every Pod gets an IP address, Services provide stable endpoints, and the network model enables communication across the entire cluster - often without needing to understand the low-level implementation details.</p> Core Principles of Kubernetes Networking <ol> <li>Each Pod gets a unique IP</li> <li>No NAT between Pods</li> <li> <p>All containers within a Pod share the same network namespace</p> </li> <li> <p>All Pods can reach each other</p> </li> <li> <p>Flat network model (no IP masquerading between Pods)</p> </li> <li> <p>Services provide stable access to Pods</p> </li> <li>Pods are ephemeral - Services give them a consistent IP + DNS name</li> </ol> Network Abstraction Layers Layer Purpose Pod Network Every Pod gets an IP, routable in-cluster Service Provides a stable endpoint for Pod groups Ingress Exposes HTTP/S services externally NetworkPolicy Controls traffic between Pods (optional) DNS in Kubernetes <p>Kubernetes includes built-in DNS resolution for:</p> <ul> <li>Services: <code>my-service.my-namespace.svc.cluster.local</code></li> <li>Pods (not recommended for direct use)</li> </ul> <p>DNS is powered by CoreDNS by default, running in the <code>kube-system</code> namespace.</p> <pre><code>nslookup my-service.default.svc.cluster.local\n</code></pre>"},{"location":"networking/#pod-to-pod-communication","title":"Pod-to-Pod Communication","text":"<ul> <li>All Pods are routable via their internal IP addresses</li> <li>No need for manual port forwarding</li> <li>Backed by a Container Network Interface (CNI) plugin (e.g., Calico, Flannel)</li> </ul>"},{"location":"networking/#service-types-covered-in-next-section","title":"Service Types (Covered in next section)Summary","text":"<ul> <li><code>ClusterIP</code> \u2013 default; internal-only</li> <li><code>NodePort</code> \u2013 exposes on every node</li> <li><code>LoadBalancer</code> \u2013 cloud provider external IP</li> <li><code>ExternalName</code> \u2013 DNS alias</li> </ul> <ul> <li>Kubernetes networking gives every Pod a unique IP and makes service discovery simple.</li> <li>All Pods can talk to each other by default-use NetworkPolicies to restrict if needed.</li> <li>Understanding the network model is key for debugging, scaling, and securing your apps.</li> </ul> <p>Tip</p> <p>Use DNS names for service discovery, and always test network policies and connectivity in staging before rolling out to production.</p>"},{"location":"operators-crds/","title":"Operators & CRDs","text":"Understanding Operators <p>Kubernetes Operators and CRDs extend the functionality of Kubernetes by allowing you to manage complex applications and define custom resources tailored to your needs. Operators are software extensions that use custom resources to manage applications and their components. They automate tasks beyond the capabilities of standard Kubernetes resources, following Kubernetes principles like the control loop.</p> Purpose of Operators <ul> <li>Installation: Deploying and configuring applications.</li> <li>Management: Managing runtime configurations.</li> <li>Scaling: Adjusting resources based on workloads.</li> <li>Healing: Detecting and recovering from failures.</li> <li>Upgrades: Updating applications to new versions.</li> </ul> Benefits of Using Operators <ul> <li>Consistency: Provides a consistent way to manage applications.</li> <li>Automation: Reduces manual intervention.</li> <li>Scalability: Manages resources efficiently.</li> </ul> Advanced Operator Features <ul> <li>Event Handling: Operators can respond to Kubernetes events to maintain desired state.</li> <li>Custom Metrics: Use custom metrics to make informed scaling decisions.</li> <li>Backup and Restore: Implement application-specific backup and restore logic.</li> </ul> Understanding Custom Resource Definitions (CRDs) Introduction to CRDs <p>CRDs allow you to define custom resources within the Kubernetes API, enabling the management of application-specific data and configurations.</p> Benefits of Using CRDs <ul> <li>Custom Resources: Tailor resources to your application's needs.</li> <li>Declarative Management: Use Kubernetes' API for management.</li> <li>Integration: Seamlessly integrate with Kubernetes tools.</li> </ul> Advanced CRD Features <ul> <li>Schema Validation: Define validation rules for custom resources to ensure data integrity.</li> <li>Versioning: Manage different versions of CRDs to support application evolution.</li> <li>Subresources: Use subresources like status and scale for additional functionality.</li> </ul> Creating a CRD <p>Define a CRD in a YAML file and apply it to your cluster.</p> <p>Example CRD Definition: <pre><code>apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  name: widgets.example.com\nspec:\n  group: example.com\n  versions:\n    - name: v1\n      served: true\n      storage: true\n      schema:\n        openAPIV3Schema:\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                size:\n                  type: string\n                color:\n                  type: string\n  scope: Namespaced\n  names:\n    plural: widgets\n    singular: widget\n</code></pre></p>"},{"location":"operators-crds/#creating-and-deploying-operators","title":"Creating and Deploying Operators","text":"Developing an Operator <p>Develop an Operator by defining custom resources and implementing controllers.</p> <pre><code># Install the Operator SDK\ncurl -LO https://github.com/operator-framework/operator-sdk/releases/download/v1.0.0/operator-sdk_linux_amd64\nchmod +x operator-sdk_linux_amd64\nsudo mv operator-sdk_linux_amd64 /usr/local/bin/operator-sdk\n\n# Create a new Operator project\noperator-sdk init --domain=example.com --repo=github.com/example-inc/memcached-operator\n\n# Define a new API\noperator-sdk create api --group cache --version v1alpha1 --kind Memcached --resource --controller\n</code></pre>"},{"location":"operators-crds/#best-practices","title":"Best Practices","text":"<ul> <li>Version Control: Use version control for Operator code and CRDs.</li> <li>Testing: Implement thorough testing to ensure reliability.</li> <li>Documentation: Provide clear documentation for usage and maintenance.</li> <li>Security: Follow security best practices to protect data and configurations.</li> </ul>"},{"location":"overview/","title":"Getting Started","text":""},{"location":"overview/#historical-background","title":"Historical BackgroundIntroduction to KubernetesWhat is Kubernetes?Key Concepts of Kubernetes","text":"<p>Kubernetes was born from Google's internal systems like Borg and Omega, which managed containerized applications like Search and Gmail at a massive scale. In 2014, Google open-sourced Kubernetes, and it quickly became the standard for container orchestration.</p> <p>Kubernetes (K8s) is like the air traffic controller for your applications - making sure everything is running, scaling, and healing automatically. Originally created by Google and now maintained by the CNCF, Kubernetes helps you run containers (small, portable application units) across clusters of computers.</p> <p>Kubernetes is a platform that automates the deployment, scaling, and management of containerized applications. Think of it as an operating system for your data center, making sure your apps are always running the way you want.</p> <p>Key things Kubernetes does for you:</p> <ul> <li>Deployment: Launches and manages containers for your apps.</li> <li>Scaling: Adds or removes copies of your app as needed.</li> <li>Self-healing: Restarts or replaces containers if they fail.</li> <li>Rolling Updates/Rollbacks: Updates your app with zero downtime and can revert if something goes wrong.</li> </ul> Declarative Model <p>Kubernetes uses a \"declarative\" approach: you describe how you want your system to look, and Kubernetes works to make it so - automatically.</p> <p>Three key ideas:</p> <ol> <li>Observed State: What\u2019s actually running right now.</li> <li>Desired State: What you want running (defined in YAML or JSON).</li> <li>Reconciliation: Kubernetes constantly checks and adjusts to make observed = desired.</li> </ol> <p>How it works:</p> <ul> <li>You tell Kubernetes (with <code>kubectl</code> or a YAML file) what you want.</li> <li>Kubernetes saves this in its database (etcd).</li> <li>Controllers keep checking: does reality match what you asked for?</li> <li>If not, Kubernetes takes action to fix it.</li> </ul> Declarative Approach in Kubernetes <p>You define what you want, Kubernetes keeps it that way. Here\u2019s a visual summary:</p> <pre><code>sequenceDiagram\n    participant User\n    participant APIServer as API Server\n    participant etcd\n    participant Controller as Controller Manager\n    participant Scheduler\n\n    User-&gt;&gt;APIServer: Declare desired state\n    APIServer-&gt;&gt;etcd: Persist desired state\n\n    Controller-&gt;&gt;APIServer: Check actual vs. desired\n    APIServer--&gt;&gt;Controller: current != desired\n    Controller-&gt;&gt;APIServer: Reconcile differences\n\n    APIServer-&gt;&gt;Scheduler: Trigger scheduling if needed</code></pre> <p>Tip: Most real-world Kubernetes work is about describing the desired state in YAML files.</p> <p>This diagram illustrates how Kubernetes manages resources declaratively, ensuring the system's state aligns with the user's specifications.</p> Kubernetes Architecture <p>Kubernetes architecture consists of several key components:</p> <ul> <li>API Server: The front-end for the Kubernetes control plane, handling all REST operations.</li> <li>etcd: A consistent and highly-available key-value store used as Kubernetes' backing store for all cluster data.</li> <li>Scheduler: Assigns workloads to nodes based on resource availability.</li> <li>Controller Manager: Runs controllers to regulate the state of the cluster.</li> <li>Kubelet: Ensures containers are running in a Pod on each node.</li> </ul> Services <p>Services provide stable networking endpoints for Pods, enabling reliable communication between different parts of an application. They abstract away the ephemeral nature of Pods, which can be created and destroyed dynamically, and give you a stable, long-lived connection point to the underlying Pods.</p>"},{"location":"overview/#common-features-primer","title":"Common Features PrimerSummary","text":"Pods and Deployments <ul> <li>Pods: The smallest deployable units in Kubernetes, which can contain one or more containers. Containers within Pods share resources like network and storage.</li> <li>Deployments: Higher-level controllers that manage Pods, providing features like scaling, rolling updates, and rollbacks.</li> </ul> Self-Healing and Scaling <p>If you use a Deployment or StatefulSet, Kubernetes will:</p> <ul> <li>Replace failed Pods automatically</li> <li>Scale your app up or down based on demand</li> <li>Keep your app highly available and efficient</li> </ul> Rolling Updates and Rollbacks <p>With Deployments, Kubernetes can update your app with zero downtime - gradually swapping out old Pods for new ones. If a problem is detected, it can roll back to the previous version automatically.</p> <p>Kubernetes is all about automation, reliability, and making sure your apps run the way you want. By describing your desired state, Kubernetes does the heavy lifting to keep everything running smoothly - so you can focus on building, not babysitting, your infrastructure.</p>"},{"location":"pods-deployments/","title":"Pods & Deployments","text":"Pods &amp; Deployments <p>Kubernetes runs everything inside a Pod, but in real-world production, you rarely manage Pods directly. Instead, you use Deployments to automate, heal, and update your applications.</p> What is a Pod? <p>A Pod is the smallest unit you can deploy in Kubernetes. It wraps one or more containers that:</p> <ul> <li>Share the same network (IP and ports)</li> <li>Can share storage</li> <li>Are managed as a single unit</li> </ul> <p>Most Pods have just one container, but sometimes you need tightly-coupled containers together (like a main app and a helper/sidecar).</p> <p>Key traits:</p> <ul> <li>Pods are short-lived and disposable.</li> <li>If a Pod crashes, it won\u2019t restart by itself (unless managed by something higher-level).</li> <li>Pods stick to the Node they\u2019re scheduled on until they die.</li> </ul> <p> </p> <pre><code>flowchart TD \n    subgraph \"Pod\"\n        subgraph \"container\"\n        H[\"application\"]\n        end\n    end</code></pre> What is a Deployment? <p>A Deployment is a manager for your Pods. It ensures the right number are running, replaces them if they fail, and allows you to update your app with zero downtime.</p> <p>With Deployments, you get:</p> <ul> <li>Automated management of Pod replicas</li> <li>Rolling updates and safe rollbacks</li> <li>Automatic replacement of failed Pods</li> <li>Easy version control for your app</li> </ul> <p>You describe your desired state in a YAML file, and Kubernetes makes it happen.</p> Relationship Between Pods and Deployments <p>Think of a Pod as a coffee machine in a busy caf\u00e9. It makes drinks, does its job, and eventually wears out or breaks.</p> <p>Now imagine the Deployment as the caf\u00e9 manager:</p> <ul> <li>They make sure there are always enough coffee machines running.</li> <li>If one breaks, they replace it.</li> <li>If demand increases, they bring in more.</li> <li>If an update to the machine model is needed, they roll them out gradually and safely.</li> </ul> <p>So while a Pod is the worker, the Deployment manages the workforce and ensures consistency, scalability, and resiliency over time.</p> <p>When you apply a Deployment spec:</p> <ol> <li>Kubernetes creates a ReplicaSet.</li> <li>The ReplicaSet creates the desired number of Pods.</li> <li>If any Pod dies, the ReplicaSet spawns a replacement.</li> </ol> When to Use What? <p>Use Pods directly:</p> <ul> <li>For quick experiments or debugging</li> <li>One-off tasks (but consider <code>Job</code> for this)</li> <li>Learning and testing</li> </ul> <p>Use Deployments:</p> <ul> <li>Always use for production workloads</li> <li>When you want automatic healing, scaling, and updates</li> <li>For anything that needs to run reliably over time</li> </ul> <p>Tip</p> <p>In almost all cases, use Deployments for your applications. Pods alone are for special situations.</p> Summary <ul> <li>Pods are the basic building block, but not self-healing or scalable on their own.</li> <li>Deployments manage Pods, giving you automation, scaling, and reliability.</li> <li>For production, always use Deployments.</li> </ul>"},{"location":"psa/","title":"Pod Security","text":"<p>Pod Security Admission (PSA) is the built-in mechanism in Kubernetes for enforcing security standards on Pods at the API level. Introduced in Kubernetes v1.22 and stable in v1.25, it replaced the deprecated PodSecurityPolicy (PSP) feature.</p> <p>PSA evaluates Pod specifications during creation or update and applies policy controls based on predefined security profiles.</p> Key Concepts <p>PSA is implemented as an admission controller that checks incoming Pod specs and enforces or audits their compliance with a chosen security profile.</p> <p>There are three policy levels, each defining a different set of security requirements:</p> Level Description <code>privileged</code> No restrictions - full access to host features <code>baseline</code> Minimally restrictive, prevents known high-risk settings <code>restricted</code> Highly restrictive, follows best practices for multi-tenant hardening <p>Each namespace can have policies assigned in one of three modes:</p> Mode Description <code>enforce</code> Reject non-compliant Pods <code>audit</code> Log violations but allow the Pod <code>warn</code> Send warnings to the user, but allow the Pod Configuring PSA <p>PSA is enabled by default in modern Kubernetes clusters. You can configure policy levels on a per-namespace basis using labels.</p> Example: Apply <code>restricted</code> policy with all modes <pre><code>kubectl label namespace secure-ns \\\n  pod-security.kubernetes.io/enforce=restricted \\\n  pod-security.kubernetes.io/enforce-version=latest \\\n  pod-security.kubernetes.io/audit=restricted \\\n  pod-security.kubernetes.io/audit-version=latest \\\n  pod-security.kubernetes.io/warn=restricted \\\n  pod-security.kubernetes.io/warn-version=latest\n</code></pre> <p>This enforces, audits, and warns against any pod that doesn\u2019t meet the <code>restricted</code> policy level.</p> Policy Examples <p>Here are a few settings disallowed at each level:</p> Setting baseline restricted <code>hostNetwork: true</code> \u274c \u274c <code>privileged: true</code> \u274c \u274c <code>runAsNonRoot: false</code> \u2705 \u274c <code>allowPrivilegeEscalation: true</code> \u2705 \u274c <code>capabilities.add: [\"ALL\"]</code> \u274c \u274c Summary <ul> <li>Pod Security Admission (PSA) enforces security standards for Pods at the API level.</li> <li>Use PSA to prevent risky Pod configurations and enforce best practices per namespace.</li> <li>Choose the right policy level and mode for your environment.</li> </ul> <p>Tip</p> <p>Start with <code>baseline</code> or <code>restricted</code> in new namespaces, and use <code>audit</code> and <code>warn</code> modes to monitor for violations before enforcing.</p>"},{"location":"psa/#when-to-use-each-profile","title":"When to Use Each Profile","text":"Use Case Recommended Level Development namespace baseline CI/CD pipelines baseline Multi-tenant cluster workloads restricted System workloads or privileged apps privileged"},{"location":"quiz/","title":"Quiz","text":"Which command lists all Pods in the current namespace?<code>kubectl get pods</code><code>kubectl list pods</code><code>kubectl pods</code><code>kubectl ps</code>Submit What is the smallest deployable unit in Kubernetes?PodContainerDeploymentJobSubmit Which file format is most commonly used for Kubernetes manifests?YAMLJSONINITOMLSubmit Which object manages stateless replicas and rolling updates?DeploymentStatefulSetDaemonSetServiceSubmit Which component runs on every node and manages containers?kubeletkube-proxyscheduleretcdSubmit What is etcd\u2019s primary role in Kubernetes?Store cluster state and configurationBalance network trafficRun Pods on nodesProvide container runtimeSubmit Which object exposes a set of Pods as a stable network endpoint?ServiceIngressEndpointSliceNetworkPolicySubmit The default Service type is\u2026ClusterIPNodePortLoadBalancerExternalNameSubmit Which command shows detailed info about a specific Pod?<code>kubectl describe pod </code><code>kubectl info pod </code><code>kubectl details pod </code><code>kubectl show pod </code>Submit What does a ConfigMap store?Non-sensitive configuration dataTLS private keysContainer imagesNode credentialsSubmit Which object should store passwords or API keys?SecretConfigMapServiceAccountRoleSubmit A DaemonSet ensures that a Pod\u2026Runs on every (or selected) nodeHas persistent storageScales with CPU usageCan receive external trafficSubmit A StatefulSet primarily provides\u2026Stable network IDs and ordered, persistent PodsAutomatic image updatesNode-level loggingIn-cluster DNS recordsSubmit Which command applies a manifest file?<code>kubectl apply -f file.yaml</code><code>kubectl use file.yaml</code><code>kubectl run file.yaml</code><code>kubectl start -f file.yaml</code>Submit NodePort Services\u2026Expose the Service on the same port across all nodesExpose only within the clusterRequire an Ingress controllerAlways allocate port 443Submit Which controller ensures a specified number of identical Pods are running?ReplicaSetJobCronJobEndpointSliceSubmit Which object provides HTTP routing and TLS termination at L7?Ingress (with controller)Service ClusterIPEndpointNodePort onlySubmit What does <code>kubectl logs</code> show?Container logs from a PodNode kernel logsAPI server audit logsetcd change logSubmit The Kubernetes scheduler is responsible for\u2026Placing Pods on suitable nodesCreating ReplicaSetsUpgrading the control planePersisting cluster stateSubmit RoleBinding grants permissions\u2026To a subject within a specific namespaceCluster-wide to all usersOnly to nodesOnly to ServiceAccounts in kube-systemSubmit ClusterRole vs. Role difference?ClusterRole can apply cluster-wide; Role is namespace-scopedClusterRole is for nodes onlyRole is immutableClusterRole can only read resourcesSubmit Taints on a node\u2026Repel Pods unless they tolerate the taintForce Pods to co-locateExpose node ports externallyRemove labels from nodesSubmit What\u2019s the counterpart allowing Pods onto tainted nodes?TolerationsAffinitySelectorsAnnotationsSubmit Node selectors on a Pod\u2026Constrain scheduling to nodes with matching labelsConfigure network ACLsSet resource limitsSelect Services by labelSubmit Pod anti-affinity does what?Encourages Pods to avoid co-locating on the same nodeForces Pods to run on the same nodeBlocks scheduling entirelyAuto-scales PodsSubmit Which probe determines if traffic should be sent to a container?readinessProbelivenessProbestartupProbehealthProbeSubmit Liveness vs Readiness - pick the best statement.Liveness checks if the process is alive; Readiness gates trafficBoth gate traffic onlyReadiness restarts the containerLiveness exposes a ServiceSubmit What is a Job used for?Run Pods to completion (once or a set number)Maintain a fixed number of replicasExpose workloads externallyPersist cluster configSubmit CronJob adds which capability?Time-based scheduling for JobsHorizontal scalingPod priorityBlue/green deploymentSubmit What is a LimitRange?Policy to set default/maximum resource requests &amp; limits per objectNode CPU hard capStorage quota per namespaceA Pod anti-affinity ruleSubmit ResourceQuota does what?Caps aggregate resource consumption per namespaceEnforces Pod security policiesManages node pool sizeSchedules critical Pods firstSubmit NetworkPolicy objects can restrict\u2026Ingress and egress traffic to/from PodsService creationNode taintsetcd access control listsSubmit The kube-proxy component primarily\u2026Implements Service virtual IPs and simple load-balancingSchedules PodsStores API objectsMounts volumesSubmit A CustomResourceDefinition (CRD) allows you to\u2026Extend the Kubernetes API with new resource typesReplace the API serverModify kubelet flags on nodesCreate new namespaces automaticallySubmit An Admission Controller can\u2026Intercept/validate/mutate API requests before persistenceAssign Pod IPsBalance traffic across ServicesManage node OS upgradesSubmit Which command shows current resource usage (metrics) for Pods?<code>kubectl top pods</code><code>kubectl htop</code><code>kubectl metrics pods</code><code>kubectl get metrics</code>Submit PersistentVolumeClaim (PVC) represents\u2026A user\u2019s request for storage resourcesA node\u2019s local diskA storage class driverA snapshot policySubmit A StorageClass is used to\u2026Dynamically provision volumes with parameters and reclaim policiesLabel nodes for storageEncrypt SecretsExpose storage via NodePortSubmit What does imagePullPolicy: IfNotPresent do?Pulls the image only if it\u2019s not cached on the nodeAlways pulls the imageNever pulls the imagePulls once per namespaceSubmit PodDisruptionBudget (PDB) helps\u2026Limit voluntary disruptions to maintain minimum available PodsLimit CPU throttlingConfigure NetworkPolicy defaultsForce node cordon during updatesSubmit What is kubeadm primarily used for?Bootstrap/upgrade a secure Kubernetes clusterPackage chartsProvide CNI pluginsCollect node logsSubmit Which field ensures Pods start in a defined order in StatefulSets?<code>podManagementPolicy</code> (OrderedReady)<code>runPolicy: Sequential</code><code>startupProbe: serial</code><code>initOrder: ascending</code>Submit Pod priority and preemption allow\u2026Higher-priority Pods to evict lower-priority ones during pressureNodes to share CPUServices to gain public IPs automaticallyCRDs to load earlierSubmit An Init Container runs\u2026Before app containers start, to perform setup tasksAfter all containers exitOnly on the first nodeConcurrently with all containersSubmit What does a Sidecar container commonly provide?Auxiliary features like logging, proxying, or config reloadingStorage provisioningNode health checksetcd clusteringSubmit EndpointSlice improves over Endpoints by\u2026Scaling better for large numbers of endpointsEncrypting all pod-to-pod trafficReplacing Services entirelyForcing sticky sessionsSubmit Which object defines fine-grained pod-to-pod DNS records?Headless ServiceNodePort ServiceIngressNetworkPolicySubmit Which <code>kubectl</code> command lets you run a command inside a running container?<code>kubectl exec -it  -- </code><code>kubectl run -it  </code><code>kubectl attach </code><code>kubectl shell </code>Submit What label key is commonly used by Services to select Pods?<code>app or app.kubernetes.io/name</code><code>podIP</code><code>controller-revision-hash</code><code>node-role.kubernetes.io/control-plane</code>Submit An IngressClass resource\u2026Selects which controller should implement a given IngressAssigns public IPs to ServicesCreates TLS certificatesConfigures kube-proxy modesSubmit"},{"location":"quotas-limits/","title":"Quotas & Limits","text":"Resource Quotas &amp; LimitRanges <p>In a multi-tenant Kubernetes environment, you need to make sure no single team or workload can hog all the resources. Kubernetes provides two key tools for this: ResourceQuotas and LimitRanges.</p> <p>These help admins enforce fair resource allocation, cost controls, and capacity planning.</p> ResourceQuota <p>A ResourceQuota sets a hard cap on the total resource usage (CPU, memory, object counts, etc.) within a namespace.</p> <p>If the sum of all Pods in the namespace exceeds the quota, new requests are denied.</p> Example: Memory &amp; CPU Quota <pre><code>apiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: dev-quota\n  namespace: dev\nspec:\n  hard:\n    requests.cpu: \"2\"\n    requests.memory: \"4Gi\"\n    limits.cpu: \"4\"\n    limits.memory: \"8Gi\"\n</code></pre> <p>This restricts total requested and limited CPU/memory for all Pods in the <code>dev</code> namespace.</p> Example: Object Count Quota <pre><code>spec:\n  hard:\n    pods: \"10\"\n    configmaps: \"20\"\n    persistentvolumeclaims: \"5\"\n</code></pre> <p>You can limit the number of objects like Pods, ConfigMaps, or PVCs to enforce soft multi-tenancy boundaries.</p> LimitRange <p>A LimitRange sets default values and upper/lower bounds for container-level resource usage within a namespace.</p> <p>It ensures developers don\u2019t accidentally omit or misuse resource definitions.</p> Example: Default Limits and Requests <pre><code>apiVersion: v1\nkind: LimitRange\nmetadata:\n  name: default-resources\nspec:\n  limits:\n  - default:\n      cpu: 500m\n      memory: 512Mi\n    defaultRequest:\n      cpu: 250m\n      memory: 256Mi\n    type: Container\n</code></pre> <p>This sets:</p> <ul> <li>A default request and limit if none is provided in the Pod spec.</li> <li>A guardrail to prevent containers from consuming too much by default.</li> </ul>"},{"location":"quotas-limits/#when-to-use-quotas-vs-limitranges","title":"When to Use Quotas vs LimitRangesSummaryBest Practices","text":"Feature ResourceQuota LimitRange Scope Namespace-wide Per container Controls total usage \u2705 \u274c Sets defaults \u274c \u2705 Enforces boundaries \u2705 (hard enforcement) \u2705 (via defaults and min/max) Common Use Multi-team environments Developer guardrails <ul> <li>ResourceQuotas: Limit total resources in a namespace.</li> <li>LimitRanges: Set defaults and max/min per container.</li> <li>Both are essential for multi-tenant, production-grade clusters.</li> </ul> <ul> <li>Always set quotas and limits in shared clusters. It keeps things fair, predictable, and safe for everyone.</li> <li>Monitor usage with `kubectl describe quota` or metrics dashboards.</li> <li>Document enforced limits for your teams to avoid confusion and failures.</li> </ul>"},{"location":"rbac/","title":"RBAC","text":"Core Concepts <p>RBAC controls who can do what in your Kubernetes cluster. It sets permissions for accessing the Kubernetes API and is essential for securing clusters with multiple users or teams. Kubernetes RBAC grants specific actions (verbs) on resources to users or service accounts.</p> RBAC Objects Kind Purpose <code>Role</code> Grants permissions within a single namespace <code>ClusterRole</code> Grants permissions cluster-wide <code>RoleBinding</code> Assigns a Role to a user/group in a namespace <code>ClusterRoleBinding</code> Assigns a ClusterRole to a user/group across all namespaces Example: Read-Only Role in a Namespace <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-reader\n  namespace: dev\nrules:\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"get\", \"list\"]\n</code></pre> Binding the Role <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: read-pods\n  namespace: dev\nsubjects:\n  - kind: User\n    name: alice\nroleRef:\n  kind: Role\n  name: pod-reader\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>This lets <code>alice</code> read pods in the <code>dev</code> namespace only.</p> Cluster-Wide Example <p>To give a user full access to nodes and persistent volumes across the cluster:</p> <pre><code>kind: ClusterRole\nrules:\n  - apiGroups: [\"\"]\n    resources: [\"nodes\", \"persistentvolumes\"]\n    verbs: [\"get\", \"list\", \"watch\"]\n</code></pre> <p>Bind it using a <code>ClusterRoleBinding</code> to apply cluster-wide.</p>"},{"location":"rbac/#common-verbs","title":"Common Verbs","text":"<ul> <li><code>get</code>, <code>list</code>, <code>watch</code>: Read operations</li> <li><code>create</code>, <code>update</code>, <code>patch</code>, <code>delete</code>: Write operations</li> <li><code>impersonate</code>: Required to act as another user/service account</li> </ul>"},{"location":"rbac/#common-rbac-pitfalls","title":"Common RBAC Pitfalls","text":"<ul> <li>Forgetting to bind a Role: RBAC rules do nothing unless bound</li> <li>Using <code>ClusterRole</code> when <code>Role</code> is safer</li> <li>Not scoping permissions - always follow least privilege</li> </ul>"},{"location":"rbac/#audit-rbac","title":"Audit &amp; RBAC","text":"<p>Pair RBAC with audit logging to:</p> <ul> <li>Detect excessive privileges</li> <li>Track unauthorized access attempts</li> <li>Ensure least privilege policies are followed</li> </ul>"},{"location":"rbac/#summary","title":"Summary","text":"<ul> <li>RBAC defines access to Kubernetes API resources</li> <li>Use <code>Role</code>/<code>RoleBinding</code> for namespaced access, <code>ClusterRole</code> for global access</li> <li>Grant least privilege and bind only what\u2019s necessary</li> <li>Essential for securing clusters and enabling multi-team usage</li> </ul>"},{"location":"sec-context/","title":"Security Context","text":"Security Contexts <p>A Security Context defines privilege and access control settings for a Pod or container. It\u2019s how you harden workloads against privilege escalation, file system abuse, and host access.</p> Why It Matters <p>By default, containers can:</p> <ul> <li>Run as root inside the container</li> <li>Access shared volumes with writable access</li> <li>Escalate privileges if not blocked</li> </ul> <p>Security contexts restrict and control this behavior - without needing to modify your image.</p> Pod vs Container Security Contexts <ul> <li>Pod-level applies to all containers in the Pod</li> <li>Container-level overrides the Pod-level settings</li> </ul> Common Fields Field Purpose <code>runAsUser</code> Run as specific UID inside the container <code>runAsNonRoot</code> Force non-root user <code>readOnlyRootFilesystem</code> Prevent writing to root FS <code>allowPrivilegeEscalation</code> Block <code>setuid</code> or <code>sudo</code> actions <code>privileged</code> Gives access to host-level features (avoid) <code>capabilities</code> Add/drop Linux kernel capabilities Example: Secure Container Context <pre><code>securityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  capabilities:\n    drop: [\"ALL\"]\n</code></pre> <p>This setup:</p> <ul> <li>Ensures the container isn\u2019t running as root</li> <li>Forces read-only filesystem</li> <li>Blocks privilege escalation and kernel capabilities</li> </ul>"},{"location":"sec-context/#example-pod-level-context","title":"Example: Pod-Level Context","text":"<pre><code>spec:\n  securityContext:\n    fsGroup: 2000\n    runAsUser: 1000\n</code></pre> <ul> <li><code>fsGroup</code>: Sets file group ownership for mounted volumes</li> <li>Useful when containers need write access to shared volumes</li> </ul>"},{"location":"sec-context/#avoid-privileged-mode","title":"Avoid Privileged ModeBest PracticesSummary","text":"<pre><code>securityContext:\n  privileged: true\n</code></pre> <p>This gives full host access - avoid unless you know exactly what you\u2019re doing (e.g., for a CNI plugin or host-level utility).</p> <ul> <li>Always run containers as a non-root user (<code>runAsNonRoot: true</code>).</li> <li>Use <code>readOnlyRootFilesystem: true</code> for immutable containers.</li> <li>Drop all unnecessary Linux capabilities.</li> <li>Avoid privileged mode unless absolutely necessary.</li> <li>Use Pod-level security context for shared settings.</li> <li>Always review and lock down security contexts in production workloads.</li> <li>Start with the most restrictive settings and loosen only as needed.</li> </ul> <ul> <li>Security contexts are critical for hardening workloads.</li> <li>Use them to restrict privileges, enforce non-root, and block escalation.</li> <li>Combine with PodSecurityAdmission and RBAC for a defense-in-depth approach.</li> </ul>"},{"location":"security/","title":"Security Primer","text":"Security Primer <p>Kubernetes security is like building a fortress with many walls - each layer protects your cluster, workloads, data, and users. Understanding how these layers work together is the key to a secure environment.</p> The 4Cs of Kubernetes Security <p>Kubernetes security is built on the 4Cs model:</p> <ol> <li>Cloud / Infrastructure</li> <li>Cluster</li> <li>Container</li> <li>Code</li> </ol> <p>Analogy: Think of the 4Cs as security gates: each one must be strong to keep your cluster safe.</p> <p>Each layer is an opportunity for both defense and attack. True security means securing every level.</p> Common Threat Vectors Surface Area Risk Example Misconfigured RBAC Users can access or delete sensitive resources Insecure Pods Privileged containers, exposed hostPath Unsafe Images Vulnerable base images or untrusted sources Over-permissive Network No NetworkPolicy = open lateral movement Secrets in plain text Poorly handled sensitive data <p>Tip: Most real-world incidents result from misconfigurations, not zero-day exploits.</p> Key Kubernetes Security Concepts <p>Quick overview of what matters most:</p> \ud83d\udd10 Authentication &amp; Authorization <ul> <li>Authentication: Who are you?</li> <li>Authorization (RBAC): What are you allowed to do?</li> <li>Admission Controllers: Should this action be allowed or changed?</li> </ul> <p>These protect access to the Kubernetes API and workloads.</p> \ud83e\uddf1 Pod Security <ul> <li>Prevent privilege escalation</li> <li>Block host access</li> <li>Apply security contexts</li> <li>Enforce using Pod Security Admission (PSA)</li> </ul> \ud83d\udd75\ufe0f\u200d\u2642\ufe0f Audit Logs <ul> <li>Record every API request</li> <li>Help detect suspicious or unauthorized behavior</li> <li>Required for compliance in regulated environments</li> </ul>"},{"location":"security/#image-scanning","title":"\ud83d\udd0d Image Scanning","text":"<ul> <li>Analyze container images for known vulnerabilities</li> <li>Prevent deployment of unsafe workloads</li> <li>Tools: Trivy, Grype, Cosign, Clair</li> </ul>"},{"location":"security/#secrets-management","title":"\ud83d\udd10 Secrets Management","text":"<ul> <li>Use <code>Secret</code> objects (with encryption at rest)</li> <li>Avoid embedding secrets in images or environment variables</li> <li>Consider sealed secrets or external tools like Vault</li> </ul>"},{"location":"security/#network-security","title":"\ud83d\udd12 Network Security","text":"<ul> <li>Use NetworkPolicies to restrict Pod-to-Pod traffic</li> <li>Combine with Ingress controllers and TLS</li> <li>Isolate workloads by namespace or label</li> </ul>"},{"location":"security/#shift-left-devsecops-in-kubernetes","title":"Shift Left: DevSecOps in Kubernetes","text":"<p>Modern Kubernetes security integrates with CI/CD pipelines:</p> <ul> <li>Scan containers during build</li> <li>Validate policies (e.g., with OPA/Gatekeeper)</li> <li>Reject non-compliant resources before deployment</li> </ul>"},{"location":"security/#summary","title":"Summary","text":"<p>Kubernetes security is broad and layered. The upcoming sections break it down into actionable areas like:</p> <ul> <li>Pod-level hardening (PSA)</li> <li>Audit and observability</li> <li>Image security and scanning</li> <li>Runtime policies and network controls</li> </ul> <p> Security isn't a checkbox  -  it's a process. Let\u2019s dig into each piece. </p>"},{"location":"services-networking/","title":"Services","text":"Services &amp; Networking <p>Pods are short-lived - they can appear and disappear at any time. A Service gives you a stable way to talk to a group of Pods, no matter how often those Pods restart or move.</p> What Is a Service? <p>A Kubernetes Service is like a switchboard operator for your Pods: - Selects a group of Pods (using labels) - Gives them a stable IP and DNS name - Forwards traffic to the right Pods, even as they change</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: web\nspec:\n  selector:\n    app: web\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre> <p>This exposes Pods with label <code>app=web</code> on port 80, forwarding traffic to their port 8080.</p> 1. ClusterIP (default) <p>A ClusterIP Service is for internal communication only. Think of it as a company\u2019s internal phone extension - only people inside the building (cluster) can call it.</p> <ul> <li>Internal IP address (e.g., <code>10.x.x.x</code>)</li> <li>DNS: <code>web.default.svc.cluster.local</code></li> <li>Default Service type</li> </ul> <p> </p> <p>Use When:</p> <ul> <li>Apps need to talk to each other inside the cluster (e.g., frontend \u2194 backend)</li> <li>No external access needed</li> </ul> 2. NodePort <p>A NodePort Service lets people outside your cluster reach your app using a static port on every node. It\u2019s like giving every employee in the company a direct phone number that rings their internal extension.</p> <ul> <li>Uses each node\u2019s IP + port (range: <code>30000\u201332767</code>)</li> <li>Forwards traffic from node to the right Pods</li> </ul> <pre><code>spec:\n  type: NodePort\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30080\n</code></pre> <p>Access from outside the cluster:</p> <pre><code>http://&lt;node-ip&gt;:30080\n</code></pre> <p> </p>"},{"location":"services-networking/#use-when","title":"Use When:","text":"<ul> <li>Testing external access without a LoadBalancer</li> <li>You don\u2019t have a cloud provider (e.g., on-prem clusters)</li> </ul>"},{"location":"services-networking/#3-loadbalancer","title":"3. LoadBalancer","text":"<p>A LoadBalancer Service provisions an external cloud load balancer (if supported by your environment).</p> <ul> <li>Only works with cloud providers (GCP, AWS, Azure)</li> <li>Assigns a public IP and balances across backing Pods</li> <li>Combines NodePort + external LB behind the scenes</li> </ul> <pre><code>spec:\n  type: LoadBalancer\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre> <p> </p>"},{"location":"services-networking/#use-when_1","title":"Use When:","text":"<ul> <li>You want public access to your app in a cloud environment</li> <li>You need external DNS + SSL termination (with Ingress)</li> </ul>"},{"location":"services-networking/#4-externalname-special-case","title":"4. ExternalName (Special Case)","text":"<p>Maps a Kubernetes Service to an external DNS name.</p> <pre><code>spec:\n  type: ExternalName\n  externalName: db.example.com\n</code></pre> <ul> <li>No selectors or backing Pods</li> <li>Useful for referencing external databases, APIs, etc.</li> </ul>"},{"location":"services-networking/#summary-table","title":"Summary Table","text":"Type Visibility Use Case Requires Cloud <code>ClusterIP</code> Internal only Pod-to-Pod communication \u274c No <code>NodePort</code> Exposes on node IP Direct external access via port \u274c No <code>LoadBalancer</code> External IP Cloud load balancer with public IP \u2705 Yes <code>ExternalName</code> DNS redirect External services via DNS \u274c No"},{"location":"services-networking/#summary","title":"Summary","text":"<ul> <li>Services abstract a group of Pods behind a stable IP and DNS name.</li> <li>ClusterIP is the default and internal-only.</li> <li>NodePort opens access via node IP and high port.</li> <li>LoadBalancer gives you a cloud-managed endpoint.</li> <li>ExternalName is a DNS-level alias.</li> </ul> <p> Understanding how each Service type works  -  and when to use it  -  is essential for building reliable, scalable apps in Kubernetes. </p>"},{"location":"statefulsets/","title":"StatefulSets","text":"StatefulSets <p>A StatefulSet is a Kubernetes controller for running stateful apps - apps that need each Pod to keep its identity and storage, even if rescheduled. Think databases, message queues, or anything that can't just be replaced with a blank copy.</p> Why Use a StatefulSet? <p>Use a StatefulSet when your app needs:</p> <ul> <li>Stable network identity (like <code>pod-0</code>, <code>pod-1</code>)</li> <li>Persistent storage per Pod that sticks around if the Pod is rescheduled</li> <li>Ordered startup, scaling, and deletion</li> </ul> <p>Examples: Databases (PostgreSQL, Cassandra), Zookeeper, Kafka, etc.</p> How It Differs from Deployments <p>StatefulSets guarantee identity and storage for each Pod, while Deployments just care about keeping the right number of Pods running (not which is which).</p> <p> </p> <p>Top Half (Deployment): Pod reschedule = new IP, broken volume mount Bottom Half (StatefulSet): Pod is recreated with the same IP, same volume</p> Key Features Feature Deployment StatefulSet Pod name Random (e.g., <code>pod-abc123</code>) Stable (e.g., <code>web-0</code>, <code>web-1</code>) Pod start/delete order Any Ordered Persistent VolumeClaim Shared/ephemeral One per Pod DNS hostname Random Stable via headless service Sample YAML <pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: web\nspec:\n  serviceName: \"web\"  # Headless service\n  replicas: 2\n  selector:\n    matchLabels:\n      app: web\n  template:\n    metadata:\n      labels:\n        app: web\n    spec:\n      containers:\n        - name: nginx\n          image: nginx\n          volumeMounts:\n            - name: data\n              mountPath: /usr/share/nginx/html\n      tolerations:\n      - key: \"node-role.kubernetes.io/master\"\n        operator: \"Exists\"\n        effect: \"NoSchedule\"\n  volumeClaimTemplates:\n    - metadata:\n        name: data\n      spec:\n        accessModes: [\"ReadWriteOnce\"]\n        resources:\n          requests:\n            storage: 1Gi\n</code></pre>"},{"location":"statefulsets/#networking-dns","title":"Networking &amp; DNS","text":"<p>Pods in a StatefulSet get predictable hostnames:</p> <pre><code>web-0.web.default.svc.cluster.local\nweb-1.web.default.svc.cluster.local\n</code></pre> <p>This is enabled by the headless Service:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: web\nspec:\n  clusterIP: None  # Headless\n  selector:\n    app: web\n  ports:\n    - port: 80\n</code></pre>"},{"location":"statefulsets/#volume-behavior","title":"Volume BehaviorSummary","text":"<p>Each Pod gets its own PVC:</p> <ul> <li><code>web-0</code> \u2192 <code>data-web-0</code></li> <li><code>web-1</code> \u2192 <code>data-web-1</code></li> </ul> <p>These volumes are retained even if the Pod is deleted.</p> <ul> <li>StatefulSets are for apps that need stable identity and storage.</li> <li>Use them for databases, queues, and apps that can't just be replaced with a blank Pod.</li> <li>Deployments are for stateless, replaceable workloads.</li> </ul> <p>Tip</p> <p>Only use StatefulSets when you really need sticky identity or storage. For most apps, Deployments are simpler and easier to manage.</p>"},{"location":"storage/","title":"Storage","text":"Storage in Kubernetes <p>Kubernetes provides flexible ways to persist data, from temporary in-Pod storage to persistent disks that survive Pod and node failure. You\u2019ll most commonly use Volumes, PersistentVolumes (PVs), and PersistentVolumeClaims (PVCs) to manage storage in production.</p> Types of Storage <p>Kubernetes supports several storage mechanisms:</p> Type Description <code>emptyDir</code> Temporary, pod-level storage. Deleted when Pod is gone. <code>hostPath</code> Mounts a path on the host node. Avoid in production. <code>configMap</code> / <code>secret</code> Used for injecting configs/secrets into containers. <code>persistentVolume</code> Abstracts physical storage (EBS, NFS, GCE PD, etc.). <code>volumeClaimTemplate</code> Used by StatefulSets to dynamically provision volumes. Volumes <p>Basic <code>volumes</code> are attached to a Pod spec and live as long as the Pod.</p> <pre><code>volumes:\n  - name: cache\n    emptyDir: {}\n</code></pre> <p>Use <code>emptyDir</code> for scratch space or caching - not persistent data.</p> PersistentVolumes (PVs) and PersistentVolumeClaims (PVCs) <p>To persist data beyond the life of a Pod, use the PV + PVC model:</p> <ul> <li>A PV is a piece of actual storage (disk, NFS, etc.)</li> <li>A PVC is a user\u2019s request for storage</li> <li>Kubernetes binds them together dynamically</li> </ul> PVC Example <pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: app-storage\nspec:\n  accessModes: [\"ReadWriteOnce\"]\n  resources:\n    requests:\n      storage: 1Gi\n</code></pre> Pod using the PVC <pre><code>volumes:\n  - name: app-data\n    persistentVolumeClaim:\n      claimName: app-storage\n\ncontainers:\n  - name: web\n    volumeMounts:\n      - name: app-data\n        mountPath: /data\n</code></pre>"},{"location":"storage/#volume-modes-access","title":"Volume Modes &amp; Access","text":"<p>Volume Modes:</p> <ul> <li><code>Filesystem</code> (default): mounts as a directory</li> <li><code>Block</code>: exposes the raw device</li> </ul> <p></p> <p>Access Modes:</p> <ul> <li><code>ReadWriteOnce</code>: one node read/write</li> <li><code>ReadOnlyMany</code>: multiple nodes read-only</li> <li><code>ReadWriteMany</code>: shared read/write (NFS, etc.)</li> </ul>"},{"location":"storage/#storageclasses","title":"StorageClasses","text":"<p>A <code>StorageClass</code> defines how storage should be provisioned dynamically.</p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fast\nprovisioner: kubernetes.io/gce-pd\nparameters:\n  type: pd-ssd\n</code></pre> <p>The cluster admin defines StorageClasses; PVCs can request one by name.</p> <pre><code>storageClassName: fast\n</code></pre>"},{"location":"storage/#dynamic-vs-static-provisioning","title":"Dynamic vs Static Provisioning","text":"<ul> <li>Dynamic: PVC automatically provisions a volume using a <code>StorageClass</code>.</li> <li>Static: Admin manually creates PVs, and users bind to them with matching PVCs.</li> </ul>"},{"location":"storage/#best-practices","title":"Best Practices","text":"<ul> <li>Use <code>ReadWriteOnce</code> unless your workload requires multi-node access.</li> <li>Leverage <code>StorageClass</code> for automated provisioning.</li> <li>Clean up PVCs when no longer needed - they may retain bound disks.</li> <li>Use StatefulSets if each Pod needs its own PVC.</li> </ul>"},{"location":"storage/#summary","title":"Summary","text":"<p>Storage in Kubernetes is abstracted through PVs and PVCs for flexibility and portability. Whether your app is stateless or stateful, Kubernetes can handle your storage needs - just make sure to pick the right type of volume for the job.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"Troubleshooting Kubernetes <p>Troubleshooting is a crucial skill for managing Kubernetes clusters. This section provides strategies and tools for diagnosing and resolving common issues.</p> Common Issues and Solutions Issue Description Solution CrashLoopBackOff Pod repeatedly crashing. Check logs with <code>kubectl logs &lt;pod-name&gt;</code>. ImagePullBackOff Kubernetes cannot pull the container image. Verify the image name and credentials. Node Not Ready Node is not functioning correctly. Check node status with <code>kubectl get nodes</code> and review the kubelet logs. Disk Pressure Node runs low on disk space. Free up space or add more storage. Service Not Accessible Service configuration or endpoints issue. Check service configuration with <code>kubectl get svc</code> and <code>kubectl describe svc &lt;service-name&gt;</code>. DNS Resolution Failures DNS pod status or configuration issue. Verify DNS pod status and configuration with <code>kubectl get pods -n kube-system</code>. Pod Eviction Pods are evicted due to resource constraints. Check node resource usage and adjust limits or requests. High CPU Usage Pods or nodes experiencing high CPU usage. Analyze CPU usage with <code>kubectl top</code> and optimize application resource requests. Network Latency High latency in network communication between Pods. Check network policies and configurations, and ensure sufficient bandwidth. Tools for Troubleshooting Command Description Example Usage describe Provides detailed information about resources. <code>kubectl describe pod &lt;pod-name&gt;</code> logs Retrieves logs from containers. <code>kubectl logs &lt;pod-name&gt;</code> exec Executes commands in a container. <code>kubectl exec -it &lt;pod-name&gt; -- /bin/sh</code> Monitoring and Logging <ul> <li> <p>Prometheus: Collects metrics and provides alerts. It's highly customizable and integrates well with Kubernetes. Learn more</p> </li> <li> <p>Grafana: Visualizes metrics collected by Prometheus and other sources. It offers a rich set of dashboards and visualization tools. Learn more</p> </li> <li> <p>Elasticsearch, Fluentd, Kibana (EFK) Stack: Centralizes logging and provides search capabilities. Elasticsearch stores logs, Fluentd collects and forwards them, and Kibana visualizes the data. Learn more about Elasticsearch, Fluentd, Kibana</p> </li> </ul> Best Practices <ul> <li> <p>Regular Monitoring: Continuously monitor cluster health and performance.</p> </li> <li> <p>Automated Alerts: Set up alerts for critical issues to ensure timely response.</p> </li> <li> <p>Documentation: Keep detailed records of issues and solutions for future reference.</p> </li> </ul> Summary <ul> <li>Troubleshooting is a core skill for any Kubernetes admin.</li> <li>Use <code>kubectl</code> commands, logs, and monitoring tools to diagnose issues.</li> <li>Document common issues and solutions for your team.</li> </ul> <p>Tip</p> <p>Build a troubleshooting playbook and share it with your team. Review and update it after every incident.</p>"}]}