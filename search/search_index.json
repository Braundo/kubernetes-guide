{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the Kubernetes Guide, a quick and easy-to-digest summary of core Kubernetes concepts intended to help get you from zero to proficient!  Feel free to pick and choose any section in any order, but you'll likely be best served by following along in the default order of the site.</p> <p></p> <p>Legal discalimer:  </p> <ul> <li> <p>\"Kubernetes\", \"K8s\" and the Kubernetes logo are trademarks or registered trademarks of the Linux Foundation.  </p> </li> <li> <p>Neither myself nor this site are officially associated with the Linux Foundation.  </p> </li> </ul>"},{"location":"config-maps-secrets/","title":"ConfigMaps and Secrets","text":""},{"location":"config-maps-secrets/#background","title":"Background","text":"<p>Alongside the ability to store and retrieve data, another key capability for applications is the ability to be configured or instantiated via environment variables or commands.  </p> <p>In the traditional monolithic application days, environment variables and configurations were bundled up with the application and deployed as one large object. However, in the cloud-native application model it's important to decouple these for many reasons:  </p> <ol> <li>Environment Flexibility: Decoupling allows the same application to run across different environments (development, staging, production) without code changes. Environment-specific configurations can be applied externally, improving the portability of the application.</li> <li>Scalability and Dynamic Management: When configuration is externalized, it's easier to scale applications horizontally since the configuration can be managed and applied independently. This allows for dynamic reconfiguration in response to changes in load or other factors without redeploying or restarting containers.</li> <li>Security and Sensitive Data Handling: Keeping sensitive configuration data, such as secrets and credentials, separate from the application codebase helps maintain security. It ensures that sensitive data is not exposed within the code and can be securely managed using secrets management tools.</li> <li>Continuous Deployment and Rollbacks: Decoupling facilitates continuous deployment practices by allowing configurations to be updated independently of the application. This separation also simplifies rollback procedures in case a configuration change needs to be reverted without affecting the application version that's running.</li> <li>Maintainability and Clarity: Keeping configuration separate from application code helps maintain a clean codebase and makes it clearer for developers to understand the application logic. It avoids cluttering the application with environment-specific conditionals and settings, making the code easier to maintain and evolve.  </li> </ol> <p>Let's take a look at an example from point #1 there. Imagine you have an application that runs in 3 different environments: <code>dev</code>, <code>perf</code>, and <code>prod</code>. Each environment has different configurations such as credentials, network policies, security policies, etc. In the old world, if you were to package those configurations with the application, you'd end up with three separate images stored in three separate repositories. Any time a developer needs to make an update to the application, they must ensure they update it across all three repos, rebuild all three images, and redeploy all three images.</p> <pre><code>flowchart LR\n    subgraph app repos\n        dev[(&lt;b&gt;dev&lt;/b&gt;&lt;br&gt;&lt;tt&gt;- dev credentials&lt;br&gt;- dev network policy&lt;br&gt;- dev security policy)]\n        perf[(&lt;b&gt;perf&lt;/b&gt;&lt;br&gt;&lt;tt&gt;- perf credentials&lt;br&gt;- perf network policy&lt;br&gt;- perf security policy)]\n        prod[(&lt;b&gt;prod&lt;/b&gt;&lt;br&gt;&lt;tt&gt;- prod credentials&lt;br&gt;- prod network policy&lt;br&gt;- prod security policy)]\n    end\n    subgraph app images\n        dev2[&lt;b&gt;dev image]\n        perf2[&lt;b&gt;perf image]\n        prod2[&lt;b&gt;prod image]\n    end\n    subgraph environments\n        dev3[&lt;b&gt;dev]\n        perf3[&lt;b&gt;perf]\n        prod3[&lt;b&gt;prod]\n    end\n    dev --&gt;|builds| dev2\n    perf --&gt;|builds| perf2\n    prod --&gt;|builds| prod2\n    dev2 --&gt;|deployed| dev3\n    perf2 --&gt;|deployed| perf3\n    prod2 --&gt;|deployed| prod3</code></pre> <p>A better way to handle this is by decoupling those configuration values from your application. You build and maintain a single application repository and build &amp; run that single image in all environments. For this to be possible, your applications should be built as plain as possible with as little configuration necessary embedded. The configurations for each environment are then stored separately and applied to the various environments at runtime.  </p> <p>In this manner, application code is updated in one repository, one image is used, and configurations are independently managed.</p> <pre><code>flowchart LR\n    subgraph app repo\n        app[(&lt;b&gt;app source code&lt;/b&gt;)]\n    end\n    subgraph app image\n        app2[&lt;b&gt;app image]\n    end\n    subgraph environments\n        dev[&lt;b&gt;dev]\n        perf[&lt;b&gt;perf]\n        prod[&lt;b&gt;prod]\n    end\n    subgraph ConfigMaps\n    dev1[(\"dev CM\")]\n    perf1[(\"perf CM\")]\n    prod1[(\"prod CM\")]\n    end\n    app --&gt;|builds| app2\n    app2 --&gt;|apply config| dev1\n    app2 --&gt;|apply config| perf1\n    app2 --&gt;|apply config| prod1\n    dev1 --&gt; |deployed| dev\n    perf1 --&gt; |deployed| perf\n    prod1 --&gt; |deployed| prod</code></pre>"},{"location":"config-maps-secrets/#configmaps","title":"ConfigMaps","text":"<p>Kubernetes allows this to happen through the use of a ConfigMap (CM). ConfigMaps are used to store non-sensitive information and configuration data such as:  </p> <ol> <li>Hostnames</li> <li>Server configurations</li> <li>Database configurations</li> <li>Account names</li> <li>Environment variables</li> </ol> <p>You should not use ConfigMaps to store sensitive data such as passwords. Secrets should be used for that purpose.</p> <p>Under the covers, ConfigMaps are effectively key-value pairs. Keys are completely arbitrary and can be any name created from letters, numbers, underscores, dashes, and dots. Values can contain anything. As with many other key-value paradigms, they are separated by a colon (<code>key</code>:<code>value</code>). </p> <p>As mentioned above, a (simple) database configuration might look something like this in a ConfigMap definition:</p> <pre><code>hostname: mysql-dev-01\ndb-port: 3306\nusername: vinny\n</code></pre> <p>Data stored in ConfigMaps can be injected into a container in a number of ways:  </p> <ol> <li>As environment variable(s)</li> <li>Arguments in the container's startup command</li> <li>As files in a volume</li> </ol> <p>These methods are all transparent to the application - it has no idea the ConfigMap is even a thing, it just knows it's data is where it's supposed to be. How it got there is an irrelevant mystery.</p>"},{"location":"config-maps-secrets/#environment-variables","title":"Environment Variables","text":"<p>To inject data as environment variables, you created a ConfigMap and map its entries to environment variables inside of the Pod spec template. Once the Pod and underlying container start, the environment variables will appear as standard environment variables for the OS relevant to that container.  </p> <p>Here's how that might look when injecting some database information into a container using a ConfigMap called <code>myCM</code>:  </p> <p><code>myCM</code>: <pre><code>## rest of file omitted for simplicity\ndata:\n  database: mysql-01\n  loc: STL\n  user: vinny\n</code></pre></p> <p>Pod definition: <pre><code>spec:\n  containers:\n  ...\n    env:\n      - name: host\n      valueFrom:\n        configMapKeyRef:\n          name: myCM\n          key: database\n      - name: location\n      valueFrom:\n        configMapKeyRef:\n          name: myCM\n          key: loc\n      - name: user\n      valueFrom:\n        configMapKeyRef:\n          name: myCM\n          key: user\n</code></pre></p> <p>With these configs, this is what the mapping from ConfigMap to container variables would look like:  </p> <ul> <li>database host</li> <li>loc location</li> <li>user user </li> </ul> <p>If you were to login interactively to the container, you would be able to seamlessly view these environment variables:  </p> <pre><code>$ echo $host\nmysql-01\n\n$ echo $location\nSTL\n\n$ echo $user\nvinny\n</code></pre>"},{"location":"config-maps-secrets/#container-startup-commands","title":"Container Startup Commands","text":"<p>This method of injecting data into containers from ConfigMaps is pretty straightforward. In your Pod template YAML, you specify a startup command and insert variables defined from your ConfigMap. Below is an example of inserting the database hostname from above into a startup command for the container. Here is how the Pod YAML might look:</p> <pre><code># other sections omitted for simplicity\nspec:\n  containers:\n  - name: my-container-1\n    image: busybox\n    command: [\"/bin/sh\", \"-c\", \"echo Database to use is $(host)\"]\n    env:\n      - name: host\n        valueFrom:\n          configMapKeyRef:\n            name: myCM\n            key: database\n</code></pre> <p>From this Pod definition, when the container starts it will run the following shell command that we defined:</p> <pre><code>echo Database to use is $(host)\n</code></pre> <p>In our config, we mapped <code>host</code> to the <code>database</code> key in <code>myCM</code>, which we defined as having a value of <code>mysql-01</code>. Thus, when the container runs that command, it will produce the following output:</p> <pre><code>Database to use is mysql-01\n</code></pre>"},{"location":"config-maps-secrets/#volumes","title":"Volumes","text":"<p>The most flexible way to leverage ConfigMaps is with volumes. By using them with volumes you can reference entire configuration files and make live updates to them which will be reflected in running containers. The entire process can be summed up in the following steps:</p> <ol> <li>Create a ConfigMap</li> <li>Create a ConfigMap volume in your Pod spec</li> <li>Mount the ConfigMap volume into the container</li> </ol> <pre><code>flowchart LR\n    subgraph ConfigMap\n        cm1[&lt;tt&gt;central = STL]\n        cm2[&lt;tt&gt;west = SF]\n    end\n\n    subgraph Pod\n        cmv[(ConfigMap&lt;br&gt;vol)]\n        subgraph container\n        fs[\"&lt;b&gt;/etc/regions&lt;/b&gt;&lt;br&gt;&lt;tt&gt;-- central&lt;br&gt;-- west\"]\n        end\n    end\nConfigMap --&gt; cmv\ncmv --&gt; fs</code></pre> <p>Here's an example YAML file that would create a Pod called <code>configMapVol</code>, a volume called <code>volMap</code>, and mounts the <code>volMap</code> volume to <code>/etc/regions</code>:  </p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: configMapVol\nspec:\n  volumes:\n    - name: volMap\n      configMap:\n        name: my-cm\n  containers:\n    - name: container1\n      image: busybox\n      volumeMounts:\n        - name: volMap\n          mountPath: /etc/regions\n</code></pre> <p>If you were to deploy this Pod and exec into it, you could run an <code>ls</code> command to view the files we defined in the ConfigMap diagram above mounted at <code>/etc/regions</code>:  </p> <pre><code>$ kubectl exec configMapVol -- ls /etc/regions\ncentral\nwest\n</code></pre>"},{"location":"config-maps-secrets/#secrets","title":"Secrets","text":"<p>Secrets are extremely similar in shape and function to ConfigMaps in that they hold configuration data that can be injected into containers at run-time. However, Secrets differ in the fact that they base-64 encode values and are made for storing sensitive data such as tokens, certificates, and passwords.</p> <p>These values are not encrypted by default and can easily be decoded.</p> <p>A standard flow for implementing secrets looks like this:  </p> <p><pre><code>flowchart TD\n    A[Create Secret and persist to cluster store - unencrypted] --&gt; B[Pod is configured to use Secret]\n    B --&gt; C[Secret data is transferred - unencrypted - to the node]\n    C --&gt; D[Node kubelet starts the Pod and its containers]\n    D --&gt; E[Secret is mounted into the container's temp filesystem and decoded into plain text]\n    E --&gt; F[Application consumes Secret]\n    F --&gt; G[Secret is deleted from the node once the Pod is deleted]</code></pre> Additionally here is an example of how a YAML file might look for creating a Secret:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: my-secret\ntype: Opaque\ndata:\n  password: UGFzc3dvcmQxMjM=\n  user: dmlubnk=\n\n# rest of file omitted for simplicity\n</code></pre> <p>And here's an example of how to define a Pod and use the Secret as a volume:  </p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  volumes:\n  - name: secret-vol\n    secret: \n      secretName: my-secret\n  containers:\n  - name: my-container\n    image: busybox\n    volumeMounts:\n    - name: secret-vol\n      mountPath: /etc/secrets/\n</code></pre> <p>Secrets are mounted as read-only objects in the containers to prevent accidental manipulation.</p>"},{"location":"deployments/","title":"Deployments","text":""},{"location":"deployments/#overview","title":"Overview","text":"<p>The main idea behind Deployments is that you tell Kubernetes the desired state of your application while a looping controller watches your app and continuously attempts to reconcile the actual state of your app with the desired state you previously defined.</p>"},{"location":"deployments/#deployment-spec","title":"Deployment Spec","text":"<p>The way you tell Kubernetes how you want your application to look is through the use of a YAML file (Deployment spec). When you POST the Deployment spec (via <code>kubectl</code>) to the API server, Kubernetes goes through the process of deploying your application to match the desired state and leverages a Deployment controller to continuously watch your application state.  </p> <p>It should be noted that every Deployment object will only manage a single Pod object. If you have an application with more than one Pod, you will need more than one Deployment object. But, a single Deployment object can manage any number of replicas of a given Pod.</p>"},{"location":"deployments/#replicasets","title":"ReplicaSets","text":"<p>Under the covers, Deployments actually leverage a different Kubernetes object to handle Pod scaling and reboots - the RelpicaSet. You should never be managing ReplicaSets directly, but it's good to know they exist and understand the hierarchy of control here. Containers will be wrapped in Pods, which have their scaling and self-healing managed by ReplicaSets, which in turn are managed by Deployments.</p> <pre><code>flowchart TB\n    subgraph Deployment\n        subgraph ReplicaSet\n            Pod1[Pod]\n            Pod2[Pod]\n        end\n    end</code></pre>"},{"location":"deployments/#scaling-and-self-healing","title":"Scaling and Self-Healing","text":"<p>If you deploy a pod by itself (i.e. not via a Deployment), if it dies or fails, the Pod is lost forever.</p> <p>We never \"revive\" Pods; the appropriate way to \"revive\" a failed Pod is to create a new one to replace it.</p> <p>However, with the magic of Deployments, if a Pod that was created via Deployment fails, it will be replaced. Remember that Deployment controllers continuously watch for deviations from your desired state; so if you specified that your application should run 3 Pods and one of the Pods fails, the controller will recognize that actual state (2 Pods) no longer matches desired state (3 Pods), and it will kick off a series of actions to deploy another Pod.</p>"},{"location":"deployments/#rolling-updates","title":"Rolling Updates","text":"<p>This same logic allows seamless, zero-downtime updates for your applications. Let's say you defined your application to have 5 Pods running and labeled it as being <code>v1.2</code>. Your team introduces some new features or implements some bug fixes and creates <code>v1.3</code> of your application. Your next step will be to go in and update your desired state (Deployment spec) from <code>v1.2</code> <code>v1.3</code>. The Deployment controller will then recognize that the actual state (<code>v1.2</code>) no longer matches the desired state (<code>v1.3</code>) and begin the process of spinning down outdated Pods and spinning up new Pods with the new version.  </p> <p>Some things to keep in mind for this to work: your application(s) need(s) to maintain loose coupling and maintain backwards and forwards compatability (cloud native application design pattern). For upgrades or rollbacks to truly have zero-downtime, forward and backword compatibility is a must, as is having clearly defined API specs.</p> <p>There are different rolling update strategies you can employ that specify how to handle rollouts/rollbacks, how many can be spun up or down at once, etc. For more in-depth information on these strategies, refer to the official Kubernetes documentation.</p>"},{"location":"deployments/#rollbacks","title":"Rollbacks","text":"<p>Rollbacks work in the same manner as rolling updates from above but in reverse. Imagine you had an issue with <code>v1.3</code> and need to roll back to <code>v1.2</code>. It's as simple as updating your Deployment spec and letting the Deployment controller notice this change and begin that reconciliation process. Kubernetes let you specify how many revisions (old versions) of your Deployments should be maintained for the purposes of rollbacks. In your Deployment spec, this is defined by the <code>revisionHistoryLimit</code> block.  </p> <p>You can view the update history of a Deployment by running the following command: <pre><code>kubectl rollout history deployment/&lt;deployment-name&gt;\n</code></pre></p>"},{"location":"deployments/#scaling","title":"Scaling","text":"<p>Performing manual scaling operations with Deployments is also super straightforward and can be done in a similar manner to the one above. If you decide you actually want 10 Pods instead of 5, it's as simple as updating your Deployment spec and updating the <code>Replicas</code> block to the desired amount of Pods. Once again, the Deployment controller will notice the variation in states and begin reconciliation.</p>"},{"location":"dns/","title":"DNS","text":""},{"location":"dns/#service-discovery","title":"Service Discovery","text":"<p>As we saw in the previous sections, Kubernetes can be a very busy platform with Pods constantly coming and going. Services help calm some of the storm by providing a stable endpoint for clients to connect to. But how do apps find other apps on a cluster? Through Service discovery! There are two main concepts that make up Service discovery as a whole: Registration and Discovery.</p>"},{"location":"dns/#service-registration","title":"Service registration","text":"<p>This is the process of an app on Kubernetes providing its connection details to a registry in order for other apps on the cluster to be able to find it. This happens automatically when Services are created.  </p> <p>As briefly mentioned in the previous section, Kubernetes provides its own DNS service (typically referred to as the cluster DNS). It's deployed as a series of Pods managed by a Deployment called <code>coredns</code>. These Pods are behind a Service called <code>kube-dns</code>. All of these reside within the <code>kube-system</code> Namespace.  </p> <p>Every Service created on a Kubernetes cluster will automatically register itself with the cluster DNS to ensure that all Pods across the cluster can \"find\" it.</p> <p><pre><code>flowchart LR\n    SVC[&lt;b&gt;Service&lt;/b&gt;&lt;br&gt;&lt;tt&gt;foo-svc&lt;br&gt;10.0.0.8]\n    SVC --&gt; |1. Service registered| REG[&lt;b&gt;Service registry&lt;/b&gt;&lt;br&gt;&lt;tt&gt;foo-svc: 10.0.0.8]\n    CON[&lt;tt&gt;app] --&gt; |2. Discover Service| REG\n    CON --&gt; |3. Consume Service| SVC</code></pre> The high-level flow of Service registration is as follows: </p> <ol> <li>Post a Service manifest to the API server (via <code>kubectl</code>)</li> <li>The Service is given a stable IP address called a ClusterIP</li> <li>EndpointSlices are created to maintain the list of healthy Pods which match the Service's label selector</li> <li>The Service's name and IP are registered with the cluster DNS.  </li> </ol> <p>It's worth noting that cluster DNS implements its own controller which constantly watches the API server for new Services being created. When a new one is observed, it automatically creates the DNS records mappings - meaning neither applications nor Services need to perform their own Service registration.  </p> <p>Every node's <code>kube-proxy</code> also watches the API server for new EndpointSlices and creates local networking rules when one is observed. This helps with redirecting ClusterIP traffic to Pod IPs.</p>"},{"location":"dns/#service-discovery_1","title":"Service Discovery","text":"<p>The best way to explain discovery is likely through an example. So let's assume we have two applications on the same cluster - <code>ham</code> and <code>eggs</code>. Each application has their Pods fronted by a Service, which in turn each has their own ClusterIP.</p> <pre><code>$ kubectl get svc\nNAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\nham-svc   ClusterIP     192.168.1.200               443/TCP   5d19h\neggs-svc  ClusterIP     192.168.1.208               443/TCP   5d19h\n</code></pre> <p>Visually depicted as follows:  </p> <pre><code>flowchart\n    subgraph ham app\n        direction TB\n        ham-svc[\"&lt;b&gt;ham-svc&lt;/b&gt;\\n&lt;tt&gt;name: ham\\nIP: 192.168.1.200\\nPort: 443\"] --- Pod1[\"Pod\"]\n        ham-svc --- Pod2[\"Pod\"]\n        ham-svc --- Pod3[\"Pod\"]\n    end\n    subgraph kube-dns\n        direction TB\n        dns-svc[\"Cluster DNS\"]\n        dns-svc --- svc-reg[\"&lt;b&gt;registry&lt;/b&gt;&lt;br&gt;&lt;tt&gt;eggs: 192.168.1.208&lt;br&gt;ham: 192.168.1.200\"]\n    end\n    subgraph eggs app\n        direction TB\n        eggs-svc[\"&lt;b&gt;eggs-svc&lt;/b&gt;\\n&lt;tt&gt;name: eggs\\nIP: 192.168.1.208\\nPort: 443\"] --- Pod4[\"Pod\"]\n        eggs-svc --- Pod5[\"Pod\"]\n        eggs-svc --- Pod6[\"Pod\"]\n    end</code></pre> <p>In order for the <code>ham</code> application to communicate with the <code>eggs</code> application, it needs to know two things:  </p> <ol> <li>The name of the <code>eggs</code> application's Service (<code>eggs-svc</code>)</li> <li>How to convert that name to an IP address</li> </ol> <p>In the case of #1, it's the responsibility of the application developers to know which applications they need to communicate with. Kubernetes internal DNS handles point #2.  </p> <p>As mentioned above, Kubernetes automatically configures each container in the cluster to be able to resolve the IP address of the cluster DNS Service. It also appends any relevant search domains to unqualified names. It performs these actions by populating the <code>/etc/resolv.conf</code> on every container.  </p> <p>ClusterIPs exist on their own special Service network, so it takes a bit of work for traffic to get there. One thing to note is that every node in a cluster has a <code>kube-proxy</code> controller that creates IPVS rules any time a new Service is created. The steps that occur after an application attempts to communicate with another application on the cluster is a series of routing steps that can be summarized as follows:</p> <ol> <li>The application container's default gateway routes the traffic to the node it is running on.</li> <li>The node itself does not have a route to the Service network so it routes the traffic to the node kernel.</li> <li>The node kernel recognizes traffic intended for the service network (recall the IPVS rules) and routes the traffic to a healthy Pod that matches the label selector of the Service.  </li> </ol>"},{"location":"dns/#namespaces","title":"Namespaces","text":"<p>A key point in understanding cluster DNS is knowing that Namespaces are able to partition a cluster's address space. Cluster address spaces are typically denoted as <code>cluster.local</code> and then have object names prepended to it. For instance, the <code>ham-svc</code> Service from above exists in the default Namespace and would have an FQDN of <code>ham-svc.default.svc.cluster.local</code>.  </p> <p>Now imagine you wanted to partition the cluster domain further with <code>perf</code> and <code>qa</code> Namespaces. For a <code>ham-svc</code> Service in each of those Namespaces, the address would look as follows:</p> <ul> <li>Perf: <code>ham-svc.perf.svc.cluster.local</code></li> <li>QA: <code>ham-svc.qa.svc.cluster.local</code></li> </ul> <p>Objects within the same Namespace can connect to each other using short names. However, cross-Namespace communication must use the FQDN. To visualize this, take the following setup where we have a Service in each Namespace fronting a few Pods:</p> <pre><code>flowchart\n    subgraph qa Namespace\n        direction TB\n        eggs-svc[\"&lt;tt&gt;eggs-svc&lt;/b&gt;\"] --- Pod1[\"&lt;tt&gt;scrambled\"]\n        eggs-svc --- Pod2[\"&lt;tt&gt;fried\"]\n        eggs-svc --- Pod3[\"&lt;tt&gt;poached\"]\n    end\n    subgraph perf Namespace\n        direction TB\n        ham-svc[\"&lt;tt&gt;ham-svc&lt;/b&gt;\"] --- Pod4[\"&lt;tt&gt;bacon\"]\n        ham-svc --- Pod5[\"&lt;tt&gt;sausage\"]\n        ham-svc -.-|&lt;tt&gt;ham-svc| Pod6[\"&lt;tt&gt;salt\"]\n        eggs-svc -.-|&lt;tt&gt;eggs-svc.qa.svc.cluster.local| Pod6[\"&lt;tt&gt;salt\"]\n    end</code></pre> <p>For the <code>salt</code> Pod to communicate with the <code>ham-svc</code> Service, it can simply reference it by it's short name (<code>ham-svc</code>) since they are within the same <code>perf</code> Namespace.  </p> <p>However, for <code>salt</code> to communicate with the <code>eggs-svc</code> Service, which resides in the <code>qa</code> Namespace, it would have to leverage it's FQDN: <code>eggs-svc.qa.svc.cluster.local</code>.</p>"},{"location":"ingress/","title":"Ingress","text":""},{"location":"ingress/#overview","title":"Overview","text":"<p>Ingress aims to bridge the gap that exists with NodePort and LoadBalancer Services. NodePorts are great, but must use a high port number and require you to know the FQDN or IP address of your nodes. LoadBalancer Services don't require this, but they are limited to one internal Service per load-balancer. So, if you have 50 applications you need exposed to the internet, you'd need 50 of your cloud provider's load-balancers instantiated - which would probably be cost prohibitive in most cases.  </p> <p>Ingresses come into play here by allowing multiple Services to be \"fronted\" by a single cloud load-balancer. To accomplish this, Ingress will use a single LoadBalancer Service and use host-based or path-based routing to send traffic to the appropriate underlying Service.  </p> <pre><code>flowchart LR\n    CLD[cloud] --&gt; LBS\n    LBS[&lt;b&gt;LoadBalancer&lt;br&gt;Service] --&gt; ing1[&lt;b&gt;Ingress controller&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;i&gt;- routing rules&lt;br&gt;- reading host &amp;&lt;br&gt;path names]\n    ing1 --&gt; SVC1[&lt;tt&gt;svc a]\n    ing1 --&gt; SVC2[&lt;tt&gt;svc b]\n    ing1 --&gt; SVC3[&lt;tt&gt;svc c]</code></pre>"},{"location":"ingress/#routing-examples","title":"Routing Examples","text":""},{"location":"ingress/#host-based-routing","title":"Host-based Routing","text":"<p><pre><code>flowchart LR\n    CLD[client] --&gt; |ham.foo.bar| LBS\n    CLD[client] --&gt; |eggs.foo.bar| LBS\n    LBS[&lt;b&gt;LoadBalancer&lt;br&gt;Service] --&gt; ing1[&lt;b&gt;Ingress controller]\n    ing1 --&gt; |ham.foo.bar|SVC1[&lt;b&gt;ham-svc]\n    ing1 --&gt; |eggs.foo.bar|SVC2[&lt;b&gt;eggs-svc]</code></pre> </p>"},{"location":"ingress/#path-based-routing","title":"Path-based Routing","text":"<pre><code>flowchart LR\n    CLD[client] --&gt; |foo.bar/ham| LBS\n    CLD[client] --&gt; |foo.bar/eggs| LBS\n    LBS[&lt;b&gt;LoadBalancer&lt;br&gt;Service] --&gt; ing1[&lt;b&gt;Ingress controller]\n    ing1 --&gt; |foo.bar/ham|SVC1[&lt;b&gt;ham-svc]\n    ing1 --&gt; |foo.bar/eggs|SVC2[&lt;b&gt;eggs-svc]</code></pre>"},{"location":"ingress/#more-information","title":"More Information","text":"<p>For a deeper dive into Ingress, refer to the official Kubernetes documentation.</p>"},{"location":"kubernetes-api/","title":"Kubernetes API","text":""},{"location":"kubernetes-api/#overview","title":"Overview","text":"<p>Kubernetes revolves entirely around its API, which serves as the central nervous system of the platform. Every interaction within Kubernetes\u2014whether it's creating, reading, updating, or deleting resources like Pods and Services\u2014occurs through requests made to the API and processed by the API server.  </p> <p>While <code>kubectl</code> is the go-to command-line tool for sending these requests, they can also be composed programmatically or via specialized API development tools. Regardless of how they're formulated, all requests are funneled to the API server, where they undergo authentication and authorization checks. Once verified, these requests are actioned within the cluster. For instance, a request to create a resource results in its deployment to the cluster, and the object's configuration is then stored in the cluster's datastore. This API-centric design ensures a consistent and secure method for managing the cluster's state and operations.  </p> <pre><code>---\ntitle: API request flow\n---\nflowchart LR\n    client[\"&lt;b&gt;client\"] --&gt;\n    id1{{\"API server&lt;br&gt;auth\"}} --&gt;\n    api{{\"&lt;tt&gt;API\"}} --&gt;\n    sched{{\"&lt;tt&gt;Scheduler\"}} --&gt;\n    etcd{{\"&lt;tt&gt;Cluster&lt;br&gt;store\"}}</code></pre> <p>In Kubernetes, the intricate dance of communication is choreographed with serialization, where objects like Pods and Services are transformed into JSON strings for transmission over HTTP. This transformation occurs both ways: clients such as <code>kubectl</code> serialize objects to JSON when making requests to the API server, and the API server does the same when sending back responses. What's more, Kubernetes captures the serialized state of these objects in the cluster's persistent storage, commonly etcd, ensuring the cluster's state is maintained and recoverable.  </p> <p>Serialization in Kubernetes isn't limited to JSON; it also embraces Protobuf, a schema known for its speed and efficiency, outpacing JSON in performance and scalability. However, Protobuf's complexity makes it less accessible for direct inspection and debugging, which is why it's primarily utilized for internal communications within the cluster, while JSON remains the go-to format for external client interactions.  </p> <p>To smooth out the serialization process, clients specify their supported formats using the Content-Type header in their HTTP requests. For instance, a client that only understands JSON will declare <code>Content-Type: application/json</code>, prompting Kubernetes to respond with data serialized in JSON, adhering to the client's capabilities and preferences.  </p> <p>Kubernetes is a world of API-defined objects, ranging from the familiar Pods and Services to the traffic-managing Ingresses. All these elements are accessible via the API server, which acts as the gateway for interaction with the cluster. You typically use kubectl, the command-line interface, to make requests for these objects. The beauty of Kubernetes extends to its extensibility, allowing third parties to define custom resources that are just as accessible through kubectl and the API server.  </p> <p>When you make a request for an object, the API server springs into action, creating that object within your cluster. But it doesn't just stop there; the API server provides a watch functionality, letting you observe the object as it comes to life. Once the object is up and running, Kubernetes maintains a vigilant watch over it, with the API server offering real-time insight into its current state. Whether you're scaling up with more objects or pruning with deletions, these interactions are all routed through the central hub of the API server.  </p> <pre><code>sequenceDiagram\n    participant User\n    participant kubectl\n    participant API_Server\n    participant Cluster_Store\n\n    User-&gt;&gt;kubectl: Request Object Creation\n    kubectl-&gt;&gt;API_Server: Create Object\n    API_Server-&gt;&gt;Cluster_Store: Serialize and Persist Object\n    Cluster_Store--&gt;&gt;API_Server: Confirm Object Stored\n    API_Server--&gt;&gt;kubectl: Object Creation Watch\n    kubectl--&gt;&gt;User: Object Status Updates\n    Note over User,Cluster_Store: Object is now ready for use\n\n    User-&gt;&gt;kubectl: Query Object State\n    kubectl-&gt;&gt;API_Server: Get Object State\n    API_Server-&gt;&gt;Cluster_Store: Retrieve Object Data\n    Cluster_Store--&gt;&gt;API_Server: Object Data\n    API_Server--&gt;&gt;kubectl: Object State\n    kubectl--&gt;&gt;User: Object State Response</code></pre>"},{"location":"kubernetes-api/#api-server","title":"API Server","text":"<p>The Kubernetes API server is the central hub through which all interactions in the cluster are routed, functioning as the front-end interface for Kubernetes' API. Picture it as the Grand Central Station of Kubernetes \u2014 every command, status update, and inter-service communication passes through the API server via RESTful calls over HTTPS. Here's a snapshot of how it operates:  </p> <ul> <li><code>kubectl</code> commands are directed to the API server, whether it's for creating, retrieving, updating, or deleting Kubernetes objects.</li> <li>Node Kubelets keep an eye on the API server, picking up new tasks and sending back their statuses.</li> <li>The control plane services don't chat amongst themselves directly; they communicate through the API server.  </li> </ul> <p>Zooming in on the API server itself, it's part of the Kubernetes control plane services, often running as a Pod set within the kube-system Namespace on the control plane nodes. For those managing their own Kubernetes clusters, ensuring the high availability and robust performance of the control plane is crucial to keep the API server operational. In contrast, for hosted Kubernetes services, these details are abstracted away from the user.  </p> <p>At its core, the API server's role is to make the Kubernetes API accessible, both to clients within the cluster and to those outside. It secures client connections with TLS encryption and applies various authentication and authorization protocols to vet and process only legitimate requests. All requests, no matter their origin, are subject to the same stringent auth checks.  </p> <p>The \"RESTful\" part of the API means it adheres to a modern web API structure that deals with CRUD-style (Create, Read, Update, Delete) requests via standard HTTP methods like <code>POST</code>, <code>GET</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>.  </p> <p>Typically, the API server is available on ports 443 or 6443, although these can be configured to suit specific needs. The flexibility of the API server ensures that it can cater to different environments while maintaining strict security and reliable service.  </p> <p>The follow command will show you the address and port your Kubernetes cluster is exposed on: <pre><code>$ kubectl cluster-info\nKubernetes control plane is running at https://192.168.1.105:6443\nCoreDNS is running at https://192.168.1.105:6443/api/v1/namespaces/...\nMetrics-server is running at https://192.168.1.105:6443/api/v1/namespaces/...\n</code></pre></p> <p>In essence, the Kubernetes API server serves as the gateway to the cluster, offering a secure, RESTful interface for interacting with the cluster's state. Operating from the control plane, it necessitates robust availability and performance to ensure swift and reliable handling of requests, embodying the critical link between the user's commands and the cluster's operational response.</p> <p>If you're unfamiliar with REST, AWS has a great one-pager to get you up to speed.  </p>"},{"location":"kubernetes-api/#api","title":"API","text":"<p>The Kubernetes API is expansive and RESTful, structured to define all Kubernetes resources. Initially, the API was a single, monolithic entity, but as Kubernetes evolved, it transitioned into a more modular form for better manageability, distinguishing between the core group and named groups of API resources.  </p> <p>Core API Group: This group houses the original, fundamental resources such as Pods, Nodes, and Services, accessible under <code>/api/v1</code>. These objects, crucial from the early Kubernetes days, have paths that may vary based on whether they are namespaced (e.g., Pods within a specific namespace) or cluster-wide (e.g., Nodes).  </p> <p>Named Groups: Representing the evolution and expansion of the Kubernetes API, named groups contain newer resources organized by functionality. For instance, the \"apps\" group includes workload-related resources like Deployments and StatefulSets, while \"networking.k8s.io\" focuses on network aspects such as Ingresses. Unlike the core group, resources in named groups are found under <code>/apis/{group-name}/{version}/</code>, reflecting their categorization and versioning.  </p> <p>This division enhances the API's scalability and navigability, facilitating the introduction of new resources. To explore available resources and their groupings, <code>kubectl api-resources</code> provides a comprehensive overview, indicating whether resources are namespaced or cluster-scoped, alongside their shortnames and API group affiliations. This command is instrumental in understanding the API's layout and the scope of resources within a Kubernetes cluster.  </p>"},{"location":"kubernetes-api/#core-group","title":"Core Group","text":"Resource REST Path Pods <code>/api/v1/namespaces{namespace}/pods/</code> Services <code>/api/v1/namespaces/{namespace}services</code> Nodes <code>/api/v1/nodes/</code> Namespaces <code>/api/v1/namespaces</code>"},{"location":"kubernetes-api/#named-groups","title":"Named Groups","text":"Resource REST Path Ingress <code>/apis/networking.k8s.io/v1/namespaces/{namespace}/ingresses/</code> RoleBinding <code>/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/</code> ClusterRole <code>/apis/rbac.authorization.k8s.io/v1/clusterroles/</code> StorageClass <code>/apis/storage.k8s.io/v1/storageclasses/</code> <p>Note: This is not all-inclusive, just a few examples.</p> <p>The <code>kubectl api-resources</code> command is a great way to see which API resources are available on your cluster, as well as useful information about them:  </p> <pre><code>$ kubectl api-resources\nNAME                              SHORTNAMES   APIVERSION     NAMESPACED\nbindings                                       v1             true\ncomponentstatuses                 cs           v1             false\nComponentStatus\nconfigmaps                        cm           v1             true\nConfigMap\nendpoints                         ep           v1             true\nEndpoints\nevents                            ev           v1             true\nlimitranges                       limits       v1             true\nLimitRange\nnamespaces                        ns           v1             false\nNamespace\nnodes                             no           v1             false\npersistentvolumeclaims            pvc          v1             true\nPersistentVolumeClaim\npersistentvolumes                 pv           v1             false\nPersistentVolume\n</code></pre> <p>Truncated for brevity</p> <p>In Kubernetes discussions, you might hear \"resources,\" \"objects,\" and \"primitives\" used as if they're the same. While common usage often blends these terms together, there's a technical distinction worth noting: Kubernetes fundamentally operates on a resource-based API model.  </p> <p>What this means: At its core, the Kubernetes API deals with \"resources.\" These resources are predominantly \"objects\" like Pods, Services, and Ingresses. Yet, the API isn't limited to objects alone; it also encompasses lists and a select few operations. Given that the bulk of resources are indeed objects, the terms \"resource\" and \"object\" are frequently used interchangeably without causing confusion.  </p> <p>Scope of Resources: Kubernetes differentiates between namespaced and cluster-scoped resources. Namespaced resources must reside within a specific Namespace, tailoring their scope and impact to that Namespace. For instance, Pods and Services require a Namespace to exist. Conversely, cluster-scoped resources either span multiple Namespaces or operate outside the Namespace system altogether. Nodes, for example, are cluster-scoped resources existing beyond Namespace boundaries, while ClusterRoles can be tied to specific Namespaces through RoleBindings to apply permissions across the cluster.  </p> <p>To get a grip on the resources available in your cluster and their scope, <code>kubectl api-resources</code> is an invaluable command. It provides a snapshot of all resources, highlighting whether they are namespaced or cluster-scoped, thereby offering insight into how Kubernetes structures and manages its diverse set of resources.  </p>"},{"location":"kubernetes-api/#extending-the-api","title":"Extending the API","text":"<p>Kubernetes offers a powerful framework for managing and automating containerized applications, largely through its predefined set of resources and controllers that observe and manage the state of objects within the cluster. Yet, one of Kubernetes' most compelling features is its extensibility, allowing you to tailor the system to your specific needs by introducing custom resources and controllers.  </p> <p>Extending Kubernetes with Custom Resources and Controllers A vivid example of such extensibility can be observed in the storage domain, where third-party vendors integrate advanced functionalities\u2014like snapshot scheduling\u2014directly into Kubernetes through custom resources. While Kubernetes natively supports storage operations through StorageClasses and PersistentVolumeClaims, these custom resources enable the exposure of vendor-specific features within the same Kubernetes ecosystem.</p> <p>The Extension Blueprint Extending the Kubernetes API typically involves two key steps:</p> <ol> <li> <p>Creating a Custom Controller: This involves developing a controller that operates on your custom logic, watching for changes to your custom resources and ensuring the desired state is achieved within the cluster.  </p> </li> <li> <p>Defining a Custom Resource: Kubernetes facilitates this through the CustomResourceDefinition (CRD) API object. CRDs allow you to define new types of resources that integrate seamlessly with the Kubernetes API, complete with their own RESTful paths. Once defined, these custom resources can be managed via <code>kubectl</code> just like built-in resources, offering a native Kubernetes experience for your custom logic.  </p> </li> </ol> <p>This approach not only enriches the Kubernetes ecosystem with new functionalities but also maintains the uniformity and coherence of the Kubernetes API, ensuring that custom resources are as accessible and manageable as the built-in ones. Through CRDs, Kubernetes embraces an extendable architecture, empowering developers to innovate and expand the platform's capabilities to meet their unique operational requirements.  </p> <p>Info</p> <p>Creating a custom resource doesn't do a whole lot unless you create a custom controller to accompany it. If you're interested in digging into those details, I recommend reading the official Kubernetes documentation on custom controllers.  </p>"},{"location":"namespaces/","title":"Namespaces","text":""},{"location":"namespaces/#overview","title":"Overview","text":"<p>Namespaces are used to partition Kubernetes clusters and provide an easy way to apply policies and quotas at a more granular level.  </p> <p>Namespaces are not intended to be used for secure isolation</p> <p>If you need secure isolation, the best practice is to use multiple clusters.</p>"},{"location":"namespaces/#common-uses-for-namespaces","title":"Common Uses for Namespaces","text":"<p>Namespaces are frequently used to separate environments within a cluster, such as differentiating between development, staging, and production. They can also be used for resource management, applying specific policies or quotas to a subset of the cluster.</p>"},{"location":"namespaces/#built-in-namespaces","title":"Built-in Namespaces","text":"<p>Kubernetes starts with several built-in Namespaces:</p> <ul> <li><code>default</code>: The space where objects are placed if no other Namespace is specified.</li> <li><code>kube-system</code>: For objects created by the Kubernetes system.</li> <li><code>kube-public</code>: Usually reserved for resources that should be visible and readable publicly throughout the whole cluster.</li> <li><code>kube-node-lease</code>: For lease objects associated with nodes which help the Kubelet in determining node health.  </li> </ul> <p>You can run the following command to view all Namespaces on a cluster:  </p> <pre><code>$ kubectl get namespaces\n    NAME              STATUS   AGE\n    default           Active   22h\n    gmp-public        Active   22h\n    gmp-system        Active   22h\n    kube-node-lease   Active   22h\n    kube-public       Active   22h\n    kube-system       Active   22h\n</code></pre> <p>Your output will vary based on your environment.  </p>"},{"location":"namespaces/#deploying-objects-to-namespaces","title":"Deploying Objects to Namespaces","text":"<p>When deploying objects on Kubernetes you can specify the target Namespace imperatively by adding the <code>-n &lt;Namespace&gt;</code> flag to your command, or declaratively by specifying the Namespace in your YAML file:  </p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\n  namespace: my-namespace\n...\n</code></pre>"},{"location":"namespaces/#namespace-creation","title":"Namespace Creation","text":"<p>Creating a new Namespace is as simple as applying a new YAML file:</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\n  name: my-new-namespace\n</code></pre> <p>You can also create a Namespace with the kubectl command:</p> <pre><code>kubectl create namespace my-new-namespace\n</code></pre>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#history","title":"History","text":"<p>Kubernetes itself was born out of Google's experience running billions of containers at scale and managing them with proprietary systems called Borg and Omega. In 2014 Google donated Kubernetes as an open-source project to the Cloud Native Computing Foundation (CNCF).</p>"},{"location":"overview/#20k-foot-view","title":"20K-foot View","text":"<p>At a high-level, Kubernetes is responsible for deploying your applications and dynamically responding to changes to keep your applications running how you intended. Kubernetes runs on any cloud or on-premise datacenter, abstracting away all of the underlying infrastructure and letting you focus on application development. All applications running on Kubernetes must be containerized, and those containers must be running inside of a Pod.  </p> <p>Fundamentally, Kubernetes is a cluster - a group of machines, so to speak. These machines are called nodes in the Kubernetes world and can be cloud instances, virtual machines, physical servers, your laptop, etc.  </p> <p>A Kubernetes cluster consists of a control plane and any number of worker nodes. The control plane is the \"brain\" of Kubernetes and handles things such as scheduling workloads to nodes, implementing the API, and watching for changes that need to be responded to. The worker nodes handle the leg-work of actually running applications.</p> <pre><code>graph TD;\n  subgraph Control Plane\n    kube-apiserver[API Server];\n    etcd[etcd];\n    kube-scheduler[Scheduler];\n    kube-controller-manager[Controller Manager];\n    cloud-controller-manager[Cloud Controller Manager];\n  end;\n  subgraph Node Components\n    kubelet[Kubelet];\n    kube-proxy[Kube Proxy];\n    container-runtime[Container Runtime];\n  end;\n  kube-apiserver --&gt; etcd;\n  kube-apiserver --&gt; kube-scheduler;\n  kube-apiserver --&gt; kube-controller-manager;\n  kube-apiserver --&gt; cloud-controller-manager;\n  kube-scheduler --&gt; kubelet;\n  kube-controller-manager --&gt; kubelet;\n  cloud-controller-manager --&gt; kubelet;\n  kubelet --&gt; kube-proxy;\n  kubelet --&gt; container-runtime;\n  kube-proxy --&gt; container-runtime;</code></pre>"},{"location":"overview/#api-server","title":"API Server","text":"<p>Speaking of, the API server is the central component for all communication for all components in Kubernetes.  </p> <p>Any communication inbound or outbound to/from the Kubernetes cluster must be routed through the API server.</p>"},{"location":"overview/#cluster-store","title":"Cluster Store","text":"<p>The control plane, like many aspects of Kubernetes, exists in a stateless manner. However, the cluster store does not - it persistently stores the state of the cluster and other configuration data. As of Kubernetes v1.28, <code>etcd</code> is the distributed databse that Kubernetes leverages for it's cluster store.  </p> <p><code>etcd</code> is installed on every control plane node by default for high-availability. However, it does not tolerate split-brain scenarios and will prevent updates to the cluster in such states - but it will still allow applications to run in those scenarios.</p>"},{"location":"overview/#controllers","title":"Controllers","text":"<p>Kubernetes consists of many different controllers, which are essentially background loops that watch for changes to the cluster (and alert when things don't match up so other components can take action). All controllers are managed and implemented by a higher-level component called the controller manager. </p> <p>The following logic is at the core of what Kubernetes is and how it works:  </p> <pre><code>flowchart LR\n    subgraph ControlLoops\n    A(Obtain&lt;br&gt;&lt;b&gt;desired&lt;/b&gt; state)\n    B(Observe&lt;br&gt;&lt;b&gt;current&lt;/b&gt; state)\n    end\n    B -.-&gt; api(API Server)\n    A -.-&gt; etcd[(etcd)]\n    ControlLoops --&gt; C{current &lt;br&gt;=&lt;br&gt; desired?}\n    C --&gt;|Yes| ControlLoops\n    C --&gt;|No| E[Take action]</code></pre>"},{"location":"overview/#declarative-model","title":"Declarative Model","text":"<p>Key to truly mastering Kubernetes is the concept of the declarative model. You tell Kubernetes how you want your application to look and run (how many replicas, which image to use, network settings, commands to run, how to perform updates, etc.), and it's Kubernetes job to ensure that happens. You \"tell\" Kubernetes through the use of manifest files written in YAML.  </p> <p>You take those manifest files and <code>POST</code> them to the Kubernetes API server (typically through the use of <code>kubectl</code> commands). The API server will then authenticate the request, inspect the manifest for formatting, route the request to the appropriate controller (i.e. if you've defined a manifest file for a Deployment, it will send the request to the Deployments controller), and then it will record your desired state in the cluster store (remember, <code>etcd</code>). After this, the relevant controller will get started on performing any tasks necessary to get your application into it's desired state.  </p> <p>After your application is up and running, controllers begin monitoring it's state in the background and ensuring it matches the desired state in <code>etcd</code> (see simple logic diagram above).</p>"},{"location":"overview/#primitives","title":"Primitives","text":"<p>Many of these primitives will not make sense until you read through the various sections of this guide; but this will be a good diagram to refer back to:  </p> <pre><code>graph TB\n    subgraph Controllers\n        Deployment\n        ReplicaSet\n        StatefulSet\n    end\n    subgraph Services\n        Service\n        Ingress\n    end\n    subgraph Volumes\n        PersistentVolumeClaim\n        PersistentVolume\n    end\n    subgraph Config\n        ConfigMap\n        Secret\n    end\n    subgraph Policies\n        NetworkPolicy\n        HorizontalPodAutoscaler\n        RBAC\n    end\n    Pod[\"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Pod&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\"]\n    Deployment --&gt;|manages| ReplicaSet\n    ReplicaSet --&gt;|controls| Pod\n    Service --&gt;|routes traffic to| Pod\n    PersistentVolumeClaim --&gt;|claims| PersistentVolume\n    Pod --&gt;|mounts| PersistentVolumeClaim\n    Ingress --&gt;|exposes| Service\n    Pod --&gt;|uses| ConfigMap\n    Pod --&gt;|uses| Secret\n    NetworkPolicy --&gt;|controls access to| Pod\n    HorizontalPodAutoscaler --&gt;|scales| Deployment\n    RBAC --&gt;|secures| Pod\n    StatefulSet --&gt;|manages|Pod</code></pre>"},{"location":"pods/","title":"Pods","text":"<p>Pods are the atomic unit of scheduling in Kubernetes. As virtual machines were in the VMware world, so are Pods in the world of Kubernetes. Every container running on Kubernetes must be wrapped up in a Pod. Think of a Pod as a wrapper for your application\u2019s container(s), similar to how a virtual machine encapsulates an entire operating system and its applications.  </p> <p>The most simple implementation of this are single-container Pods - one container inside one Pod. However there are certain instances where multi-container Pods make sense.</p> <p>It's important to note that when you scale up/down applications in Kubernetes, you're not doing so by adding/removing containers directly - you do so by adding/removing Pods.</p>"},{"location":"pods/#atomic","title":"Atomic","text":"<p>Pod deployment is atomic in nature - a Pod is only considered Ready when all of its containers are up and running. Either the entire Pod comes up successfully and is running, or the entire thing doesn't - there are no partial states.</p>"},{"location":"pods/#lifecycle","title":"Lifecycle","text":"<p>Pods are designed to be ephemeral in nature. Once a Pod dies, it's not meant to be restarted or revived. Instead, the intent is to spin up a brand new Pod in the failed ones place (based off of your defined manifest). Further, Pods are immutable and should not be changed once running. If you need to change your application, you update the configuration via the manifest and deploy a new Pod.  </p> <p>Pods also follow a defined restart policy in order to handle container failures:  </p> <ul> <li><code>Always</code>: The container is restarted even if it exits successfully.</li> <li><code>OnFailure</code>: The container is only restarted if it exits with an error.</li> <li><code>Never</code>: The container is never restarted, regardless of the exit status.</li> </ul>"},{"location":"pods/#shared-resources-and-communication","title":"Shared Resources and Communication","text":"<p>Containers within a Pod share an IP address and port space, allowing them to communicate using localhost. They can also share volumes, providing a common space for storage that persists across container restarts and simplifies data sharing.</p>"},{"location":"pods/#multi-container-pods","title":"Multi-container Pods","text":"<p>As mentioned above, the simplest way to run an app on Kubernetes is to run a single container inside of a single Pod. However, in situations where you need to tightly couple two or more functions you can co-locate multiple containers inside of the same pod. One such example would be leveraging the sidecar pattern for logging wherein the main container dumps logs to a supporting container that can sanitize and format the logs for consumption. This frees up the main container from having to worry about formatting logs.  </p>"},{"location":"pods/#affinity-and-anti-affinity","title":"Affinity and Anti-affinity","text":"<p>Kubernetes offers ways to control where Pods are placed relative to other Pods or to specific nodes. Pod affinity rules attract Pods to nodes with specific labels, while anti-affinity rules repel them, ensuring high availability and optimal resource utilization.</p>"},{"location":"pods/#resource-requests-and-limits","title":"Resource Requests and Limits","text":"<p>Pods can specify the amount of CPU and memory required (requests) and the maximum that can be consumed (limits). This helps Kubernetes make better scheduling decisions and manage system resources efficiently.</p>"},{"location":"pods/#probes-readiness-and-liveness","title":"Probes: Readiness and Liveness","text":"<p>Kubernetes uses readiness probes to know when a Pod is ready to start accepting traffic and liveness probes to know when to restart a container:</p> <ul> <li>Readiness probes protect your service\u2019s availability by not sending traffic to Pods that aren\u2019t ready.</li> <li>Liveness probes help maintain a healthy application state by restarting containers that fail the defined check.</li> </ul>"},{"location":"pods/#init-containers","title":"Init Containers","text":"<p>Init containers run before the application containers and are used to perform setup tasks or wait for some condition before the app starts. They run to completion and must exit before the main application containers start.</p>"},{"location":"pods/#quality-of-service-qos-classes","title":"Quality of Service (QoS) Classes","text":"<p>Pods are assigned QoS classes based on their resource requests and limits:</p> <ul> <li><code>Guaranteed</code>: Pods with defined and equal requests and limits, ensuring the highest priority.</li> <li><code>Burstable</code>: Pods with defined requests lower than limits, giving some flexibility.</li> <li><code>BestEffort</code>: Pods with no requests or limits, receiving the lowest priority.</li> </ul>"},{"location":"pods/#pod-disruption-budgets","title":"Pod Disruption Budgets","text":"<p>Pod Disruption Budgets (PDBs) allow you to ensure that a minimum number of Pods are always available during voluntary disruptions, such as node maintenance, safeguarding against outages.</p>"},{"location":"pods/#annotations-and-labels","title":"Annotations and Labels","text":"<p>Labels are key/value pairs for organizing and selecting groups of Pods, while annotations provide a way to store additional metadata to help manage applications.</p>"},{"location":"pods/#service-accounts","title":"Service Accounts","text":"<p>Pods use service accounts to authenticate to the Kubernetes API, which is crucial for Pods that need to interact with the API for automation and orchestration.</p>"},{"location":"pods/#summary","title":"Summary","text":"<p>Pods are the building blocks of a Kubernetes application. They ensure that containers run in a controlled, isolated, and secure environment with all the necessary configurations and resources. While Pods are inherently transient, their patterns and behaviors are foundational to how applications are designed and managed in Kubernetes. For more granular control and advanced features, refer to the official Kubernetes documentation.</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#overview","title":"Overview","text":"<p>In Kubernetes, everything from creating new resources to updating or deleting them involves making requests to the API server. This is true for everyone and everything in the Kubernetes ecosystem: from developers using <code>kubectl</code>, to the Pods running in your cluster, to the kubelets on each node, and the control plane services that oversee cluster operations.  </p> <p>Let's take an example: imagine a user named \"vinny\" wants to deploy a new application using a Deployment named \"treats\" in the \"petropolis\" Namespace. vinny runs a <code>kubectl apply</code> command, which sends a request to the API server. This request is securely sent over TLS, carrying vinny's credentials. The API server first authenticates vinny, making sure they are who they claim to be. Next, it checks if vinny has the permissions (via RBAC) to create Deployments in the petropolis Namespace. If vinny passes these checks, the request goes through admission control for any additional policy checks before being executed on the cluster.</p>"},{"location":"security/#authentication-authn","title":"Authentication (AuthN)","text":"<p>Authentication is all about proving who you are. It's often referred to as \"authN.\" At its core are credentials\u2014every request to the API server must include them. The authentication layer checks these credentials; if they don\u2019t match, you get a \"401 Unauthorized\" response. If they check out, you move on to authorization.  </p> <p>Kubernetes doesn\u2019t keep its own user database; instead, it connects to external systems like Active Directory or cloud IAM services for identity management. This setup prevents the creation of redundant identity systems. While Kubernetes supports client certificates out of the box, for practical use, you'll likely integrate it with your existing identity management system. Hosted Kubernetes services usually offer easy integration with their native IAM solutions.  </p>"},{"location":"security/#checking-your-authentication-setup","title":"Checking Your Authentication Setup","text":"<p>Your connection details to Kubernetes are stored in a <code>kubeconfig</code> file. This file tells tools like <code>kubectl</code> which cluster to talk to and which credentials to use. It includes sections for defining clusters, users, contexts (which pair a user with a cluster), and the current context (the default cluster-user pair for commands).  </p> <p>The <code>clusters</code> section outlines details like the cluster's API server endpoint and its CA's public key. The <code>users</code> section lists user names and their tokens, which are often X.509 certificates signed by a trusted CA. The <code>contexts</code> section pairs users with clusters, and the <code>current-context</code> sets the default for commands.  </p> <p>Given a specific <code>kubeconfig</code>, <code>kubectl</code> commands are directed to the specified cluster and authenticated as the defined user. If your cluster uses an external IAM, it handles the authentication. Once authenticated, the request can proceed to authorization, where Kubernetes decides if you have the necessary permissions to carry out your request.  </p>"},{"location":"security/#authorization","title":"Authorization","text":"<p>After you've proven your identity to Kubernetes (that's authentication), you're faced with authorization, often abbreviated as authZ. This is where Kubernetes decides if you're allowed to do what you're asking to do, like creating or deleting resources.</p> <p>Kubernetes uses a modular system for authorization, meaning you can have different methods in play. But once any method says \"yes\" to a request, it's off to the next step: admission control. The most common method for making these decisions is Role-Based Access Control (RBAC).</p>"},{"location":"security/#key-concepts-in-rbac","title":"Key Concepts in RBAC","text":"<p>RBAC boils down to three main ideas:</p> <ul> <li>Users: Who is making the request?</li> <li>Actions: What are they trying to do?</li> <li>Resources: What are they trying to do it to?</li> </ul> <p>Essentially, RBAC controls which users can perform which actions on which resources.</p>"},{"location":"security/#rbac-in-action","title":"RBAC in Action","text":"<p>In RBAC, you'll deal with Roles and RoleBindings:</p> <ul> <li>Roles specify permissions (what actions can be performed on what resources).</li> <li>RoleBindings link those permissions to users.</li> </ul> <p>For example, you might have a Role that allows reading Deployments in a specific Namespace and a RoleBinding that grants a user those read permissions.</p> <pre><code>kind: Role\nmetadata:\n  namespace: petropolis\n  name: read-deployments\nrules:\n- apiGroups: [\"apps\"]\n  resources: [\"deployments\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n</code></pre> <p>This Role, by itself, doesn't do much. It needs to be connected to a user through a RoleBinding:</p> <pre><code>kind: RoleBinding\nmetadata:\n  name: read-deployments\n  namespace: petropolis\nsubjects:\n- kind: User\n  name: vinny\nroleRef:\n  kind: Role\n  name: read-deployments\n</code></pre> <p>With this setup, a user named \"vinny\" can list, watch, and get deployments in the \"petropolis\" Namespace.</p>"},{"location":"security/#the-bigger-picture","title":"The Bigger Picture","text":"<p>Kubernetes doesn't just have Roles and RoleBindings; there are also ClusterRoles and ClusterRoleBindings for cluster-wide permissions. This system allows you to define permissions once at the cluster level and then apply them to specific Namespaces as needed.</p> <p>Most Kubernetes setups come with a set of pre-created roles to get you started, including powerful roles like <code>cluster-admin</code> that should be used cautiously.</p>"},{"location":"security/#authorization-takeaways","title":"Authorization Takeaways","text":"<p>Authorization in Kubernetes, especially through RBAC, is about specifying what authenticated users are allowed to do within the cluster. It's a system built on allowing certain actions while denying everything else by default, making it crucial to carefully manage permissions to maintain security and functionality in your cluster.</p> <p>Once a request clears the authentication and authorization stages, it's evaluated by admission control to apply any further policies before being executed on the cluster.</p>"},{"location":"security/#understanding-admission-control-in-kubernetes","title":"Understanding Admission Control in Kubernetes","text":"<p>After a request passes through authentication and authorization, it encounters the final gatekeeper before being executed: admission control. This stage is where Kubernetes applies various policies to ensure the request aligns with cluster rules and standards.</p>"},{"location":"security/#types-of-admission-controllers","title":"Types of Admission Controllers","text":"<p>Kubernetes employs two main types of admission controllers:</p> <ul> <li>Mutating Admission Controllers: These can alter requests to ensure they comply with policies. For example, they might add a missing label to an object to meet a labeling policy.</li> <li>Validating Admission Controllers: These verify requests against policies but don't modify the requests. If a request violates a policy, it's rejected.</li> </ul> <p>Mutating controllers operate before validating ones, ensuring that any modifications are in place before final checks are made. Only requests that would change the cluster's state are subject to admission control; read-only requests bypass this process.</p>"},{"location":"security/#example-in-action","title":"Example in Action","text":"<p>Imagine you have a policy requiring all objects to include an <code>app=shop</code> label. A mutating controller could automatically add this label if it's missing from a request, whereas a validating controller would reject any request lacking the label.</p>"},{"location":"security/#admission-control-on-a-cluster","title":"Admission Control on a Cluster","text":"<p>On Docker Desktop, for instance, the <code>NodeRestriction</code> admission controller is enabled by default, limiting what nodes can modify within their scope. Real-world clusters typically enable a broader set of controllers for comprehensive policy enforcement.</p> <p>A notable example is the <code>AlwaysPullImages</code> controller, a mutating type that ensures Pods always pull their container images from a registry, preventing the use of potentially unsafe local images and ensuring only nodes with proper registry credentials can pull and run containers.</p>"},{"location":"security/#admission-controls-role","title":"Admission Control's Role","text":"<p>If any admission controller rejects a request, it stops there\u2014no further processing occurs. But if a request gets the green light from all controllers, it's saved to the cluster store and deployed.</p> <p>Admission controllers are increasingly crucial for maintaining the security and integrity of production clusters, given their power to enforce policies directly on incoming requests.</p>"},{"location":"security/#recap-of-authn-authz-and-rbac","title":"Recap of AuthN, AuthZ, and RBAC","text":"<ul> <li> <p>Authentication (AuthN) validates who you are, using credentials included in every API server request. While Kubernetes doesn't manage user identities internally, it integrates with external systems for robust identity checks.</p> </li> <li> <p>Authorization (AuthZ), particularly through RBAC, dictates what authenticated users can do. It's a system of allowing specific actions via Roles and RoleBindings, ensuring users have only the permissions they need.</p> </li> <li> <p>Admission Control is the last hurdle, enforcing policies on requests post-authorization. It plays a key role in keeping the cluster secure by either modifying requests to align with policies (mutating) or rejecting those that don't comply (validating).</p> </li> </ul> <p>Throughout these stages, TLS secures communication, ensuring that sensitive information remains protected as it travels to the Kubernetes API server.</p>"},{"location":"services/","title":"Services","text":""},{"location":"services/#overview","title":"Overview","text":"<p>As mentioned in the Deployments section, Pods will likely be spinning up and down a lot in your environment throughout the course of updates, rollbacks, failures, etc. As such, it's never a good idea for any client to connect directly to a Pod. Pods are there one minute, gone the next - awfully unreliable in and of themselves.  </p> <p>This is where Services come in. Services provide stable, long-lived connection points for clients to connect to. They also maintain a list of Pods to route to and provide basic load-balancing capabilities. With Services, the underlying Pods can come and go, but any client should be able to maintain open communication with the application as the Service provides the logic to know which Pods are healthy and where to route traffic.  </p> <pre><code>flowchart LR\n    client --&gt; SVC[Service]\n    SVC --&gt; Pod1[Pod]\n    SVC --&gt; Pod2[Pod]\n    SVC --&gt; Pod3[Pod]\n    SVC --&gt; Pod4[Pod]\n\n    subgraph Deployment\n        Pod1\n        Pod2\n        Pod3\n        Pod4\n    end</code></pre>"},{"location":"services/#labels-and-selectors","title":"Labels and Selectors","text":"<p>So how does that work? How do Services know which Pods they should be sending traffic to? The short answer is labels and selectors. In essence, when you define a Service, you specify labels and selectors that - when matched with the same ones on Pods - will route traffic to them.  </p> <p>As an example, image you want to put a stable Service in front of series of Pods that make up your shopping application. When you defined the Deployment of the application you listed the following labels and selectors for the Pods: <code>env=prod</code> and <code>app=shop</code>. Now, when you set up this new Service, you used those same labels in it's YAML definition. The new Service will find all Pods on the cluster with those same labels and is now in charge of routing traffic to them.  </p> <p>Similar to other Kubernetes objects, the Services controller will continually monitor new Pods labels and continually update it's \"list\" (more on that list later) of Pods to route to.  </p> <pre><code>flowchart LR\n    SVC[&lt;b&gt;Service&lt;/b&gt;&lt;tt&gt;&lt;br&gt;env=prod&lt;br&gt;app=shop] --&gt; Pod1[&lt;b&gt;Pod&lt;/b&gt;&lt;tt&gt;&lt;br&gt;env=prod&lt;br&gt;app=shop]\n    SVC --&gt; Pod2[&lt;b&gt;Pod&lt;/b&gt;&lt;tt&gt;&lt;br&gt;env=prod&lt;br&gt;app=shop]\n    SVC --&gt; Pod3[&lt;b&gt;Pod&lt;/b&gt;&lt;tt&gt;&lt;br&gt;env=prod&lt;br&gt;app=shop]\n    SVC ~~~ Pod4[&lt;b&gt;Pod&lt;/b&gt;&lt;tt&gt;&lt;br&gt;env=dev&lt;br&gt;app=shop]</code></pre> <p>One thing to note is that Pods can have extra labels and still be managed by the Service if it's other labels still match. As a concrete example, both of the Pods below will still have traffic routed to them, even though one of them has a label that the Service does not.</p> <pre><code>flowchart LR\n    SVC[&lt;b&gt;Service&lt;/b&gt;&lt;tt&gt;&lt;br&gt;env=prod&lt;br&gt;app=shop] --&gt; Pod1[&lt;b&gt;Pod&lt;/b&gt;&lt;tt&gt;&lt;br&gt;env=prod&lt;br&gt;app=shop&lt;br&gt;cur=usd]\n    SVC --&gt; Pod2[&lt;b&gt;Pod&lt;/b&gt;&lt;tt&gt;&lt;br&gt;env=prod&lt;br&gt;app=shop]</code></pre>"},{"location":"services/#endpointslices","title":"EndpointSlices","text":"<p>As mentioned above, as Pods are spinning up and down, the Service will keep an updated list of Pods with the given labels and selectors. How it does this is through the use of EndpointSlices, which are effectively just dynamic lists of healthy Pods that match a given label selector.  </p> <p>Any new pods that are created on the cluster that match a Service's label selector will automatically be added to the given Service's EndpointSlice object. When a Pod disappears (fails, node goes down, etc.) it will be removed from the EndpointSlice. The net result is that the Service's EndpointSlice should always be up to date with a list of healthy pods that the Service can route to.  </p>"},{"location":"services/#service-types","title":"Service Types","text":""},{"location":"services/#clusterip","title":"ClusterIP","text":"<p>Kubernetes supports different types of Services, but the default type is ClusterIP, which is only accessible from inside the cluster. Any time you create a Service in Kubernetes it will automatically get a ClusterIP that's registered in the cluster's internal DNS service (more on the DNS service in a different section). Every single Pod on a cluster leverages the cluster's DNS service - which results in all Pods being able to resolve Service names to ClusterIPs.  </p>"},{"location":"services/#nodeport","title":"NodePort","text":"<p>Another type of Service that Kubernetes supports is called NodePort. This is very similar to ClusterIP but adds the ability for external access on a dedicated port on every node in the cluster. NodePort intentionally uses high-numbered ports (30000 - 32767) to avoid clashing with common ports. To access a NodePort Service from an external client, you simply direct traffic to the IP address of any node in the cluster on the given port. The Service will then route the request to the appropriate Pod based on it's list of healthy ones in it's EndpointSlice object.</p>"},{"location":"services/#loadbalancer","title":"LoadBalancer","text":"<p>If you're running your Kubernetes cluster on a public cloud environment you can leverage a LoadBalancer Service. This will provision an internet-facing load-balancer that you can leverage to send traffic to your Service. For more specifics on this type of Service, refer to the official Kubernetes documentation.</p>"},{"location":"statefulsets/","title":"StatefulSets","text":""},{"location":"statefulsets/#overview","title":"Overview","text":"<p>StatefulSets are a Kubernetes feature designed to manage applications that need to remember their state, such as databases or systems that keep data consistent across pod restarts. They offer each pod a stable identity and storage that sticks around even when pods are rescheduled to different machines in the cluster.  </p> <p>It's easy to compare StatefulSets with Deployments given they are v1 API objects and follow the controller architecture - but there are notable differences. StatefulSets are Kubernetes tools for running and managing applications that need to remember who they are and what they know\u2014think of them like memory keepers for your apps, such as databases that need to recall data after a reboot. Unlike Deployments that are more about stateless apps (think of them as forgetful but easily replaceable), StatefulSets make sure each of their Pods has a consistent name, network identity, and storage, even if they move around in the cluster. This makes StatefulSets perfect for when your app's individual identity and history are crucial for running smoothly.  </p> <p>StatefulSets can guarantee Pod names, volume bindings, and DNS hostnames across reboots - whereas Deployments cannot. Below are two diagrams that illustrate this point:  </p> <p><pre><code>---\ntitle: Node Replacement w/ Deployments\n---\nflowchart LR\n    subgraph _\n    dep-pod[\"&lt;b&gt;my-pod1&lt;/b&gt;&lt;br&gt;&lt;tt&gt;10.0.0.5\"]\n    vb1[(&lt;b&gt;myVol)]\n    dep-pod -.- vb1\n    end\n    _ --&gt; pf[/\"Pod/node failure\"/]\n    subgraph __\n    dep-pod2[\"&lt;b&gt;my-pod2&lt;/b&gt;&lt;br&gt;&lt;tt&gt;10.0.0.9\"]\n    end\n    pf --&gt;|\"replace failed Pod\"| __</code></pre> </p> <pre><code>---\ntitle: Node Replacement w/ StatefulSets\n---\nflowchart LR\n    subgraph _\n    ss-pod[\"&lt;b&gt;my-pod1&lt;/b&gt;&lt;br&gt;&lt;tt&gt;10.0.0.5\"]\n    vb1[(&lt;b&gt;myVol)]\n    ss-pod -.- vb1\n    end\n    _ --&gt; pf[/\"Pod/node failure\"/]\n    subgraph __\n    ss-pod2[\"&lt;b&gt;my-pod1&lt;/b&gt;&lt;br&gt;&lt;tt&gt;10.0.0.5\"]\n    vb2[(&lt;b&gt;myVol)]\n    ss-pod2 -.- vb2\n    end\n    pf --&gt;|\"replace failed Pod\"| __</code></pre> <p>Notice how with a Deployment, when a Pod is replaced it comes up with a new name, IP address, and its volume is no longer bound to it. With StatefulSets, the new Pod comes up looking exactly the same as the previous failed one.  </p> <p>Below is a typical YAML file for defining a StatefulSet:  </p> <pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: my-sts\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n    serviceName: \"my-sts\"\n    replicas: 5\n    template: \n      metadata:\n        labels:\n          app: nginx\n      spec:\n        containers:\n        - name: nginx-container\n          image: nginx:latest\n\n# other sections omitted for simplicity\n</code></pre> <p>In this example, the name of the StatefulSet is <code>my-sts</code> and it defines 5 Pod replicas that will run the latest version of the NGINX image. Once you post this to the API server (via <code>kubectl</code>), the definition will be persisted to the cluster store (<code>etcd</code>), replicas will be assigned to nodes, and the StatefulSet controller will begin monitoring the state of the cluster to ensure observed = desired.  </p>"},{"location":"statefulsets/#naming","title":"Naming","text":"<p>One nice feature of StatefulSets is that all Pods managed by them get a predictable name. The format of the names given to Pods managed by StatefulSets is <code>&lt;StatefulSet name&gt;-&lt;integer&gt;</code>. The integer begins with 0 and increases each time a new Pod from this StatefulSet is deployed. So in the example of <code>my-sts</code> above, the Pods would have the names of <code>my-sts-0</code>, <code>my-sts-1</code>, <code>my-sts-2</code>, <code>my-sts-3</code>, etc.</p> <p>StatefulSet names need to be valid DNS names</p>"},{"location":"statefulsets/#order-of-creationdeletion","title":"Order of Creation/Deletion","text":"<p>StatefulSets in Kubernetes are all about order and precision. They initiate and terminate Pods one at a time, following a strict sequence. This approach guarantees that each Pod is fully operational and ready to handle requests before the next Pod in the sequence is brought to life. Unlike the more free-form Deployments, which may initiate a bunch of Pods at once through a ReplicaSet\u2014potentially tripping over themselves with race conditions\u2014StatefulSets are the thoughtful orchestrators ensuring each Pod gets the attention it needs to start or stop without a rush.  </p> <pre><code>---\ntitle: Deploying a StatefulSet\n---\nflowchart \n    subgraph StatefulSet\n        pod1[&lt;b&gt;&lt;tt&gt;my-sts-0] --&gt; |\"waiting for running and ready\"|pod2[&lt;b&gt;&lt;tt&gt;my-sts-1] --&gt; |\"waiting for running and ready\"|pod3[&lt;b&gt;&lt;tt&gt;my-sts-2] --&gt; |\"waiting for running and ready\"|pod4[&lt;b&gt;&lt;tt&gt;...]\n    end</code></pre> <p>StatefulSets in Kubernetes not only ensure a methodical boot-up but also adhere to a careful scaling strategy, both up and down. For instance, when scaling from five to seven replicas, the StatefulSet will sequentially initiate each new Pod and ensure it's fully operational before moving on to the next. Conversely, during scale-down, the StatefulSet will remove Pods starting from the highest index, allowing each to decommission completely before proceeding. This step-by-step approach is critical for applications like databases, where simultaneous termination could lead to data loss.  </p> <p>StatefulSets also offer mechanisms like the <code>terminationGracePeriodSeconds</code> to fine-tune this process, ensuring no data is compromised. Moreover, unlike Deployments which rely on a ReplicaSet for managing replicas, StatefulSet controllers handle scaling and self-healing autonomously, ensuring stateful applications maintain their integrity and data throughout their lifecycle.  </p> <p>Deleting a StatefulSet does not terminate Pods in order</p> <p>If you want to terminate StatefulSet Pods in order, consider scaling to 0 replicas before deleting the StatefulSet.</p>"},{"location":"statefulsets/#statefulsets-and-volumes","title":"StatefulSets and Volumes","text":"<p>StatefulSets in Kubernetes are intrinsically tied to their volumes, which form an integral part of the Pods' state. Each Pod in a StatefulSet is bound to its distinct volumes, which are created simultaneously with the Pod and bear unique identifiers linking them directly to their respective Pods. Thanks to the Persistent Volume Claim (PVC) system, these volumes enjoy a separate lifecycle from the Pods, ensuring their preservation across Pod failures and deletions. When a StatefulSet Pod is terminated or fails, its volumes remain intact, ready to be reattached to any new Pod that takes its place, even if that Pod spins up on a different node within the cluster.  </p> <p>Scaling down a StatefulSet doesn't affect the existence of these volumes. If a Pod is removed during a scale-down, its dedicated volume waits patiently to be reconnected to a new Pod that may be created during a scale-up, ensuring data persistence and consistency. This feature is particularly crucial for safeguarding data in stateful applications; even if you mistakenly delete a Pod, the data is not lost, as the underlying volume can be reattached to a new Pod, effectively rescuing the situation.  </p>"},{"location":"statefulsets/#handling-failures","title":"Handling Failures","text":"<p>The StatefulSet controller in Kubernetes meticulously monitors the cluster's status, making sure the current state aligns with the intended setup. Consider a StatefulSet with five replicas; if one, say <code>my-sts-4</code>, goes down, the controller promptly replaces it, ensuring it retains the same name and rebinds it to the original volumes. </p> <p>But, complications arise if the failed Pod makes a comeback post-replacement and suddenly you've got twin Pods vying for the same volume. To avoid this, the StatefulSet controller handles failures with extra caution.</p> <p>When it comes to node failures, the controller faces a tricky challenge. If a node goes silent, it's hard to tell if it's down for good or just temporarily unreachable due to network issues, a kubelet crash, or a reboot. Since the controller can't guarantee that a termination command will reach a Pod on an unresponsive node, it hesitates to substitute Pods until it's certain of the node's fate. This precaution means that when a node appears to be down, manual intervention is usually necessary before Kubernetes will venture to replace any Pods that were running on it. This cautious approach ensures data integrity at the cost of requiring human oversight in ambiguous failure scenarios.</p>"},{"location":"statefulsets/#dns","title":"DNS","text":"<p>StatefulSets cater to applications that demand reliability and persistence in their Pods. This predictability extends to other applications and services that might need to establish direct connections with specific Pods. To enable these direct connections, StatefulSets employ a headless Service, which provides a stable DNS entry for each Pod based on its unique, predictable hostname. As a result, other components within the ecosystem can retrieve the entire roster of Pod hostnames via DNS queries, allowing for precise and direct Pod communications.  </p> <p>Below is a snippet of YAML that shows a headless Service being defined:  </p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: mysql\nspec:\n  clusterIP: None  # this is the headless Service\n---\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: sts-mysql\nspec:\n  serviceName: mysql  # this is the governing Service\n</code></pre> <p>Headless Services in Kubernetes are essentially standard Service objects that lack a dedicated IP address, achieved by setting <code>spec.clusterIP</code> to <code>None</code>. This Service transforms into what is known as a governing Service for a StatefulSet when it is referenced in the StatefulSet's configuration under <code>spec.serviceName</code>.</p> <p>Linking a headless Service to a StatefulSet in this way prompts the Service to create DNS SRV records for each Pod that fits the headless Service's label selector criteria. This setup allows other Pods and applications within the cluster to discover and connect to the StatefulSet's Pods by querying the DNS for the headless Service's name. To leverage this feature, applications will need to be specifically coded to perform such DNS lookups and handle connections to the StatefulSet members dynamically.</p>"},{"location":"statefulsets/#summary","title":"Summary","text":"<p>This section contained a lot of \"in the weeds\" information and probably warrants a quick summary. StatefulSets within Kubernetes serve as a robust solution for deploying and managing state-persistent applications. StatefulSets are equipped with the ability to self-repair, scale both upwards and downwards, and conduct orderly rollouts - although rollbacks typically require a manual process.</p> <p>StatefulSets provide each of their Pod replicas with consistent and enduring identities. This includes predictable names, DNS hostnames, and a unique set of volumes that remain associated through the Pod's lifecycle, encompassing failures, restarts, and rescheduling events. These persistent identities are not just superficial labels; they are fundamental to the StatefulSet's scaling mechanics and their interaction with persistent storage.</p> <p>To conclude, it's important to recognize that StatefulSets offer a structural blueprint rather than a complete solution. They set the stage for resilience and consistency, but it's up to the applications themselves to be architecturally compatible with the StatefulSet paradigm to fully harness its benefits.</p>"},{"location":"storage/","title":"Storage","text":""},{"location":"storage/#overview","title":"Overview","text":"<p>Arguably the most important aspect of any application is the ability to persist and retrieve data. Thankfully, Kubernetes supports a wide variety of storage back-ends and also integrates with many third-party systems that provide things such as replication, snapshots, backup and more.  </p> <p>Kubernetes can also support different types of storage - anything from objects to files or blocks. However, regardless of the type of storage or where it's located (on-premise, cloud, etc.), Kubernetes will treat it as a volume.  </p> <p>Kubernetes is able to support so many different storage types and services by leveraging the Container Storage Interface (CSI). The CSI is an established standard that provides a straightforward interface for Kubernetes.</p> <pre><code>flowchart LR\n    subgraph external storage\n        netapp[(NetApp)]\n        azureblock[(Azure)]\n        etc[(etc)]\n    end\n    netapp --&gt; CSI\n    azureblock --&gt; CSI\n    etc --&gt; CSI\n    subgraph Kubernetes cluster\n    CSI --&gt;\n    subsystem[\"&lt;b&gt;Persistent Volume subsystem&lt;/b&gt;&lt;br&gt;&lt;tt&gt;pv, pvc, sc\"]\n    end</code></pre> <p>The only thing required for an external storage provider to be surfaced as a volume in Kubernetes is for it to have a CSI plugin. On the right side of the diagram you'll also notice three Kubernetes API objects:  </p> <ul> <li>Persistent Volumes (PV): map to external storage objects</li> <li>Persistent Volume Claims (PVC): akin to \"tickets\" that authorize Pods to be able to use the relevant PV</li> <li>Storage Classes (SC): wrap the previous two in some automation</li> </ul> <p>Take an example below where our cluster is running on GKE and we have a 2TB block of storage called <code>gce-pd</code>. We then create a PV called <code>k8s-vol</code> that will map to the <code>gce-pd</code> with the <code>pd.csi.storage.gke.io</code> CSI plugin. Here's how that might look visually:  </p> <pre><code>flowchart LR\n    storage[(&lt;tt&gt;gce-pd)] --- |pd.csi.storage.gke.io|k8s[\"Kubernetes cluster\"]\n    pv[\"&lt;b&gt;k8s-vol&lt;/b&gt;&lt;br&gt;&lt;tt&gt;pv\"]\n    k8s --- pv\n    pv -.- storage\n    pv --- pvc[\"pvc fa:fa-ticket\"]\n    pvc --- pod</code></pre> <p>Multiple Pods cannot access the same volume.</p> <p>You cannot map an external storage volume to multiple PVs.</p>"},{"location":"storage/#container-storage-interface-csi","title":"Container Storage Interface (CSI)","text":"<p>The CSI is an open-source project that defines interfaces in a clear manner so that storage can be leveraged across Kubernetes (and other container orchestrators).</p> <p>While CSI is a critical piece of getting storage working in Kubernetes, unless you explicitly work on writing storage plugins you'll likely never interact with it directly. Most of your interaction with CSI will simply be referencing your relevant CSI plugin in YAML files.  </p>"},{"location":"storage/#persistent-volumes","title":"Persistent Volumes","text":"<p>At a high level, PVs are the way external storage objects are represented in Kubernetes.</p>"},{"location":"storage/#storage-classes","title":"Storage Classes","text":"<p>StorageClasses (SCs) allow you to define different types of storage. How they are defined depends on the type of storage you're using. For example, if you're using Google Cloud Storage you have classes such as Standard, Nearline, Coldline, and Archive. You may also have simpler/more straightforward classes at your disposal such as SSD and HDD. When you create a SC you map both of those definitions so Pods in your cluster can use either or.</p> External Type K8s StorageClass SSD sc-fast HDD sc-slow <p>Below is an example of how a StorageClass YAML definition may look for leveraging Google Cloud Storage:  </p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: ssd\nprovisioner: pd.csi.storage.gke.io  # Google Cloud CSI plugin\nvolumeBindingMode: WaitForFirstConsumer\nallowVolumeExpansion: true\nparameters:\n  type: pd-ssd  # Google Cloud SSD drives\n  provisioned-iops-on-create: '10000'\n</code></pre> <p>StorageClass objects are immutable. You cannot modify them after they are deployed.</p> <p>Below is the high-level flow for creating and using StorageClasses:</p> <ol> <li>Ensure you have a storage back-end (cloud, on-prem, etc.)</li> <li>Have a running Kubernetes cluster</li> <li>Install and setup the CSI storage plugin to connect to Kubernetes</li> <li>Create at least one StorageClass on Kubernetes</li> <li>Deploy Pods with PVCs that reference those Storage classes</li> </ol> <p>Below is an example YAML file that ties SC, PVC, and Pods together so you can see how they all interact:</p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: ssd  # this will be referenced by the PVC below\nprovisioner: pd.csi.storage.gke.io\nparameters:\n  type: pd-ssd\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n    name: mypvc  # this will be referenced by the Pod below\nspec:\n    accessModes:\n    - ReadWriteOnce\n    resources:\n        requests:\n            storage: 256Gi\n    storageClassName: ssd  # matches the name of the SC above\n---\napiVersion: v1\nkind: Pod\nmetadata:\n    name: mypod\nspec:\n    volumes:\n    - name: data\n    persistentVolumeClaim:\n        claimName: mypvc  # matches the name of the PVC above\n...\n</code></pre> <p>This YAML is only partially complete - it's mainly for showing the relationships between these objects via metadata.</p>"},{"location":"storage/#access-mode","title":"Access Mode","text":"<p>Kubernetes StorageClasses support three different types of volume access modes:</p> <ol> <li>ReadWriteOnce(RWO): PV can only be bound as read/write by a single PVC (or Pod)</li> <li>ReadWriteMany: PV can be bound as read/write by multiple PVCs (or Pods)</li> <li>ReadOnlyMany: PV can be bound as read-only by multiple PVCs (or Pods)</li> </ol>"},{"location":"storage/#reclaim-policy","title":"Reclaim Policy","text":"<p>When you define a reclaim policy on a volume, you tell Kubernetes how it should deal with a PV after the relevant PVC is released. There are two options that can be selected:  </p> <ol> <li>Delete: Default option that will delete the PV and any underlying storage resources on the external system itself once the PVC is released.</li> <li>Retain: This will keep the PV object as well as any underlying data on the external system. However, no PVCs can use it going forward. </li> </ol>"}]}